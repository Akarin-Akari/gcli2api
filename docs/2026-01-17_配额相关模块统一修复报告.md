# 配额相关模块统一修复报告

**日期**: 2026-01-17
**问题**: 预热逻辑不触发、配额保护失效、后台刷新调用不存在的函数
**修复策略**: 统一使用 `fetch_quota_info` 从内存缓存获取配额信息

---

## 📋 问题分析

### 用户报告的核心问题

1. **预热逻辑不触发**：模型额度满的时候 gcli2api 没有触发预热逻辑
2. **配额保护失效**：配额保护模块从未正确工作
3. **后台刷新报错**：调用了不存在的 `fetch_quota_data` 函数

### 根本原因

**所有模块都试图从 `credential_data` 中读取不存在的 `quota` 字段**：

| 模块 | 错误代码 | 问题 |
|------|----------|------|
| `smart_warmup.py` | `cred_data.get("quota", {})` | quota 不在数据库中 |
| `quota_protection.py` | `credential_data.get("quota", {})` | quota 不在数据库中 |
| `background_scheduler.py` | `fetch_quota_data(...)` | 函数不存在 |

**正确的做法**：
- ✅ 配额信息应该从 Google API 实时获取
- ✅ 使用 `fetch_quota_info` 函数（自带内存缓存）
- ✅ 不持久化配额数据到数据库

---

## 🔍 官方仓库对比

| 模块 | gcli2api_official | gcli2api (当前版本) |
|------|-------------------|---------------------|
| `SmartWarmup` | ❌ 不存在 | ✅ 存在（需修复） |
| `QuotaProtection` | ❌ 不存在 | ✅ 存在（需修复） |
| `BackgroundScheduler` | ❌ 不存在 | ✅ 存在（需修复） |

这些模块是之前开发同学参考 Antigravity-Manager 仓库添加的功能，现在由我们维护。

---

## 🛠️ 修复内容

### 1️⃣ 修复 `smart_warmup.py`

**文件**：`F:\antigravity2api\gcli2api\src\smart_warmup.py`

**修复前**：
```python
# 获取配额信息
quota_data = cred_data.get("quota", {})  # ❌ quota 不在数据库中！
models = quota_data.get("models", [])

for model in models:
    model_name = model.get("name", "")
    percentage = model.get("percentage", 0)
```

**修复后**：
```python
from src.antigravity_api import fetch_quota_info

# [FIX 2026-01-17] 从 Google API 获取配额信息（使用内存缓存）
access_token = cred_data.get("access_token") or cred_data.get("token")
if not access_token:
    log.debug(f"[SmartWarmup] {cred_name} 没有 access_token，跳过")
    continue

# 调用 fetch_quota_info（会自动使用内存缓存）
quota_result = await fetch_quota_info(access_token, cache_key=cred_name)

if not quota_result.get("success"):
    log.debug(f"[SmartWarmup] {cred_name} 获取配额失败，跳过")
    continue

# 遍历配额信息中的模型
models_data = quota_result.get("models", {})

for model_id, model_info in models_data.items():
    model_name = model_id
    # remaining 是小数（0.0-1.0），转换为百分比
    remaining_fraction = model_info.get("remaining", 0)
    percentage = remaining_fraction * 100
```

**修复位置**：
- `_scan_and_warmup` 方法（第 102-180 行）
- `trigger_manual_warmup` 方法（第 343-379 行）

---

### 2️⃣ 修复 `quota_protection.py`

**文件**：`F:\antigravity2api\gcli2api\src\quota_protection.py`

**修复前**：
```python
# 获取配额信息
quota_data = credential_data.get("quota", {})  # ❌ quota 不在数据库中！
models = quota_data.get("models", [])
```

**修复后**：
```python
from src.antigravity_api import fetch_quota_info

# [FIX 2026-01-17] 从 Google API 获取配额信息（使用内存缓存）
access_token = credential_data.get("access_token") or credential_data.get("token")
if not access_token:
    return await self._handle_no_quota_data(
        credential_name, credential_data, is_antigravity
    )

# 调用 fetch_quota_info（会自动使用内存缓存）
quota_result = await fetch_quota_info(access_token, cache_key=credential_name)

if not quota_result.get("success"):
    return await self._handle_no_quota_data(
        credential_name, credential_data, is_antigravity
    )

# 遍历配额信息中的模型
models_data = quota_result.get("models", {})

for model_id, model_info in models_data.items():
    model_name = model_id
    # remaining 是小数（0.0-1.0），转换为百分比
    remaining_fraction = model_info.get("remaining", 1.0)
    percentage = remaining_fraction * 100
```

**修复位置**：
- `check_and_protect` 方法（第 33-126 行）

---

### 3️⃣ 修复 `background_scheduler.py`

**文件**：`F:\antigravity2api\gcli2api\src\background_scheduler.py`

**修复前**：
```python
# Antigravity 凭证刷新配额
from src.antigravity_api import fetch_quota_data  # ❌ 函数不存在！
project_id = cred_data.get("project_id", "")
quota_data = await fetch_quota_data(
    credentials.access_token,
    project_id
)

# 更新配额数据
cred_data["quota"] = quota_data  # ❌ 不应该持久化到数据库！
```

**修复后**：
```python
# [FIX 2026-01-17] 使用 fetch_quota_info 从 Google API 获取配额（使用内存缓存）
# 注意：配额信息不持久化到数据库，只存在于内存缓存中
if is_antigravity:
    from src.antigravity_api import fetch_quota_info
    quota_result = await fetch_quota_info(
        credentials.access_token,
        cache_key=cred_name,
        force_refresh=True  # 强制刷新缓存
    )
    if quota_result.get("success"):
        log.info(f"[BackgroundScheduler] ✓ 配额已刷新: {cred_name}")
    else:
        log.warning(f"[BackgroundScheduler] ⚠ 配额刷新失败: {cred_name}")
else:
    # GeminiCLI 凭证 - 目前不支持配额刷新
    log.debug(f"[BackgroundScheduler] 跳过 GeminiCLI 凭证配额刷新: {cred_name}")

# 更新最后刷新时间（不存储配额数据到数据库）
cred_data["last_quota_refresh"] = time.time()
```

**修复位置**：
- `refresh_single` 内部函数（第 194-225 行）

---

### 4️⃣ 增强 `fetch_quota_info` 函数

**文件**：`F:\antigravity2api\gcli2api\src\antigravity_api.py`

**新增参数**：
```python
async def fetch_quota_info(
    access_token: str,
    *,
    cache_key: str | None = None,
    force_refresh: bool = False,  # 新增：强制刷新缓存
) -> Dict[str, Any]:
```

**修改逻辑**：
```python
# [FIX 2026-01-17] 支持 force_refresh 参数，用于后台刷新时强制更新缓存
if not force_refresh:
    expires_at = _quota_cache_expires_at.get(key, 0.0)
    if expires_at > now:
        cached = _quota_cache.get(key)
        if isinstance(cached, dict):
            return cached

fail_until = _quota_cache_fail_until.get(key, 0.0)
if fail_until > now and not force_refresh:
    # ... 冷却期逻辑
```

---

## 📊 修复效果

### 修复前的问题

| 场景 | 修复前 | 原因 |
|------|--------|------|
| **预热逻辑** | ❌ 从不触发 | 读取空的 `quota_data` |
| **配额保护** | ❌ 从不触发 | 读取空的 `quota_data` |
| **后台刷新** | ❌ 报错崩溃 | 调用不存在的函数 |

### 修复后的效果

| 场景 | 修复后 | 说明 |
|------|--------|------|
| **预热逻辑** | ✅ 正常触发 | 从 Google API 获取真实配额 |
| **配额保护** | ✅ 正常工作 | 基于真实配额百分比判定 |
| **后台刷新** | ✅ 正常运行 | 使用 `fetch_quota_info` |

---

## ⚙️ 配置说明

这些模块默认都是**禁用**的，需要在配置中启用：

| 配置项 | 默认值 | 说明 |
|--------|--------|------|
| `smart_warmup_enabled` | `False` | 启用智能预热 |
| `quota_protection_enabled` | `False` | 启用配额保护 |
| `background_refresh_enabled` | `False` | 启用后台刷新 |
| `quota_protection_threshold` | `10` | 配额保护阈值（%） |

### 启用方式

**环境变量**：
```bash
SMART_WARMUP_ENABLED=true
QUOTA_PROTECTION_ENABLED=true
BACKGROUND_REFRESH_ENABLED=true
```

**或数据库配置**：
```sql
INSERT INTO config (key, value) VALUES ('smart_warmup_enabled', 'true');
INSERT INTO config (key, value) VALUES ('quota_protection_enabled', 'true');
INSERT INTO config (key, value) VALUES ('background_refresh_enabled', 'true');
```

---

## 📝 总结

### 修复的文件

1. **`src/smart_warmup.py`** - 智能预热模块
2. **`src/quota_protection.py`** - 配额保护模块
3. **`src/background_scheduler.py`** - 后台刷新调度器
4. **`src/antigravity_api.py`** - 添加 `force_refresh` 参数
5. **`.env`** - 修复过于保守的配置参数

### 核心改进

- ✅ **统一使用 `fetch_quota_info`**：所有模块都从 Google API 获取配额
- ✅ **内存缓存**：配额信息存储在内存中，不持久化到数据库
- ✅ **强制刷新**：后台刷新时可以强制更新缓存
- ✅ **容错机制**：获取配额失败时有合理的降级处理
- ✅ **配置参数对齐**：与 Antigravity-Manager 保持一致

---

## ⚙️ 配置参数修复（追加）

### 问题发现

`.env` 文件中的配置被设置得**过于保守**，导致预热和刷新功能几乎失效：

| 配置项 | 修复前（过于保守） | 修复后（对齐 Antigravity-Manager） |
|--------|-------------------|-----------------------------------|
| `REFRESH_INTERVAL_MINUTES` | 60 分钟 | **15 分钟** |
| `SMART_WARMUP_SCAN_INTERVAL_SECONDS` | 3600 秒 (60分钟) | **600 秒 (10分钟)** |
| `SMART_WARMUP_COOLDOWN_SECONDS` | 86400 秒 (24小时) | **14400 秒 (4小时)** |
| `WARMUP_MODELS` | 只有 `gemini-3-flash` | **4个核心模型** |
| `SMART_WARMUP_MAX_CONCURRENT` | 1 | **3** |
| `SMART_WARMUP_BATCH_DELAY_SECONDS` | 5 秒 | **2 秒** |

### Antigravity-Manager 配置参考

根据 Antigravity-Manager 的源码和 README：

```rust
// src-tauri/src/modules/scheduler.rs
let mut interval = time::interval(Duration::from_secs(600));  // 10分钟扫描

// src-tauri/src/modules/scheduler.rs:132
let cooldown_seconds = 14400;  // 4小时冷却期

// src-tauri/src/models/config.rs:105
refresh_interval: 15,  // 15分钟刷新间隔
```

### 配置参数说明

| 参数 | 建议值 | 说明 |
|------|--------|------|
| `REFRESH_INTERVAL_MINUTES` | **15** | 配额刷新间隔，15分钟可以及时发现配额变化 |
| `SMART_WARMUP_SCAN_INTERVAL_SECONDS` | **600** | 预热扫描间隔，10分钟可以及时发现配额恢复到100% |
| `SMART_WARMUP_COOLDOWN_SECONDS` | **14400** | 预热冷却期，4小时匹配 Pro 账号 5 小时刷新周期（留1小时余量） |
| `WARMUP_MODELS` | 4个模型 | 包含 Claude 和 Gemini 核心模型 |
| `SMART_WARMUP_MAX_CONCURRENT` | **3** | 预热并发数，3个不会触发 RateLimit |
| `SMART_WARMUP_BATCH_DELAY_SECONDS` | **2** | 批次间延迟，2秒足够避免突发 QPS |

### 修复后的 `.env` 配置

```bash
# 后台自动刷新配额
BACKGROUND_REFRESH_ENABLED=true
REFRESH_INTERVAL_MINUTES=15
BACKGROUND_REFRESH_MAX_CONCURRENT=2

# 配额保护
QUOTA_PROTECTION_ENABLED=true
QUOTA_PROTECTION_THRESHOLD=10
QUOTA_PROTECTION_MODELS=claude-sonnet-4-5,claude-opus-4-5,gemini-3-pro

# 智能预热
SMART_WARMUP_ENABLED=true
WARMUP_MODELS=gemini-3-flash,claude-sonnet-4-5,gemini-3-pro-high,gemini-3-pro-image
SMART_WARMUP_SCAN_INTERVAL_SECONDS=600
SMART_WARMUP_COOLDOWN_SECONDS=14400
SMART_WARMUP_MAX_CONCURRENT=3
SMART_WARMUP_BATCH_DELAY_SECONDS=2
```

---

### 后续建议

1. **重启服务**：修改 `.env` 后需要重启服务才能生效
2. **监控日志**：观察 `[SmartWarmup]`、`[QuotaProtection]`、`[BackgroundScheduler]` 日志
3. **调整阈值**：根据实际使用情况调整配额保护阈值

---

## 🔧 429 Rate Limit 修复（追加）

### 问题现象

```
[03:31:44] [WARNING] [SmartWarmup] ag_fifth-mercury-tpj97-1766350344.json/gemini-3-pro-high 遇到 429，跳过
[03:31:44] [WARNING] [SmartWarmup] ag_outstanding-wonder-mwz46-1767353182.json/gemini-3-pro-high 遇到 429，跳过
[03:31:44] [WARNING] [SmartWarmup] ag_graphic-streamer-nn8hz-1766352764.json/gemini-3-pro-high 遇到 429，跳过
[03:31:48] [WARNING] [SmartWarmup] ag_reflected-polygon-mjcz2-1767353559.json/gemini-3-pro-high 遇到 429，跳过
```

### 根本原因

1. **并发执行**：`_execute_warmup_tasks` 使用 `asyncio.gather` 并发执行预热任务
2. **无全局节流**：预热请求没有使用 `_throttle_antigravity_upstream` 全局节流器
3. **突发 QPS**：4个凭证几乎同时向 Google API 发送请求，触发 429 Rate Limit

### 修复内容

#### 1️⃣ 添加全局节流器

**文件**：`F:\antigravity2api\gcli2api\src\smart_warmup.py`

**修复位置**：`_warmup_model` 方法（第 244-310 行）

```python
from src.antigravity_api import build_antigravity_headers, _throttle_antigravity_upstream

# [FIX 2026-01-17] 使用全局节流器，确保请求间隔至少 500ms，避免 429
await _throttle_antigravity_upstream()
```

#### 2️⃣ 改为串行执行

**修复位置**：`_execute_warmup_tasks` 方法（第 198-242 行）

**修复前**：
```python
# 并发执行
await asyncio.gather(*[warmup_single(task) for task in tasks])
```

**修复后**：
```python
# [FIX 2026-01-17] 改为串行执行，配合全局节流器避免 429 Rate Limit
for i, task in enumerate(tasks):
    # 执行预热（内部已有全局节流器）
    success = await self._warmup_model(cred_name, model_name, cred_data)

    # 批次间延迟（额外保护）
    if self.BATCH_DELAY_SECONDS and i < len(tasks) - 1:
        await asyncio.sleep(self.BATCH_DELAY_SECONDS)
```

### 修复效果

| 场景 | 修复前 | 修复后 |
|------|--------|--------|
| **请求间隔** | 几乎同时发送 | 至少 500ms 间隔 |
| **执行方式** | 并发（asyncio.gather） | 串行（for 循环） |
| **429 风险** | 高（突发 QPS） | 低（全局节流） |
| **日志输出** | 无进度信息 | 显示进度 (1/10) |

---

## 🔧 gemini-3-pro-high 跟随预热机制（追加）

### 问题现象

即使添加了全局节流和串行执行，`gemini-3-pro-high` 仍然频繁触发 429 Rate Limit。

### 根本原因

`gemini-3-pro-high` 模型可能有 Google 的特殊 Rate Limit 策略，比其他模型更严格。

### 解决方案

实现"跟随预热"机制：
- **普通模型**：100% 配额时独立触发预热
- **跟随模型**（如 `gemini-3-pro-high`）：只有当**同一凭证的 Claude 模型**需要预热时才顺带预热

### 修复内容

#### 1️⃣ 添加跟随模型配置

**文件**：`F:\antigravity2api\gcli2api\src\smart_warmup.py`

```python
# [FIX 2026-01-17] 跟随预热模型列表
# 这些模型不会独立触发预热，只有当同一凭证的 Claude 模型需要预热时才顺带预热
FOLLOW_WARMUP_MODELS = [
    model.strip().lower()
    for model in os.getenv("SMART_WARMUP_FOLLOW_MODELS", "gemini-3-pro-high").split(",")
    if model.strip()
]

# Claude 模型前缀（用于判断是否为 Claude 模型）
CLAUDE_MODEL_PREFIXES = ["claude-"]
```

#### 2️⃣ 修改扫描逻辑

**修复位置**：`_scan_and_warmup` 方法

```python
# [FIX 2026-01-17] 分离普通模型和跟随模型
normal_tasks = []  # 普通模型预热任务
follow_tasks = []  # 跟随模型预热任务
has_claude_warmup = False  # 是否有 Claude 模型需要预热

for model_id, model_info in models_data.items():
    # ... 检查配额和冷却期 ...

    # 判断是否为跟随模型
    if self._is_follow_model(model_name):
        follow_tasks.append(task)
    else:
        normal_tasks.append(task)
        # 检查是否为 Claude 模型
        if self._is_claude_model(model_name):
            has_claude_warmup = True

# 添加普通模型任务
warmup_tasks.extend(normal_tasks)

# 只有当有 Claude 模型需要预热时，才添加跟随模型任务
if has_claude_warmup:
    warmup_tasks.extend(follow_tasks)
else:
    skipped_follow += len(follow_tasks)
```

#### 3️⃣ 添加辅助方法

```python
def _is_follow_model(self, model_name: str) -> bool:
    """判断是否为跟随预热模型"""
    model_name_lower = model_name.lower()
    for follow_model in self.FOLLOW_WARMUP_MODELS:
        if model_name_lower.startswith(follow_model):
            return True
    return False

def _is_claude_model(self, model_name: str) -> bool:
    """判断是否为 Claude 模型"""
    model_name_lower = model_name.lower()
    for prefix in self.CLAUDE_MODEL_PREFIXES:
        if model_name_lower.startswith(prefix):
            return True
    return False
```

#### 4️⃣ 更新 .env 配置

```bash
# [FIX 2026-01-17] 跟随预热模型：这些模型不会独立触发预热，只有当同一凭证的 Claude 模型需要预热时才顺带预热
# 原因：gemini-3-pro-high 等模型有特殊的 Rate Limit 策略，频繁预热会触发 429
SMART_WARMUP_FOLLOW_MODELS=gemini-3-pro-high
```

### 修复效果

| 场景 | 修复前 | 修复后 |
|------|--------|--------|
| **gemini-3-pro-high 预热触发** | 100% 配额时独立触发 | 仅跟随 Claude 模型预热 |
| **预热频率** | 每次扫描都可能触发 | 大幅降低（仅 Claude 预热时） |
| **429 风险** | 高 | 极低 |
| **日志输出** | 无跟随信息 | 显示跳过跟随模型数量 |

### 日志示例

```
[SmartWarmup] ag_first.json 有 Claude 模型预热，顺带预热 1 个跟随模型
[SmartWarmup] ag_second.json 无 Claude 模型预热，跳过 1 个跟随模型
[SmartWarmup] 发现 3 个待预热任务 (跳过冷却期: 2, 跳过跟随模型: 5)
```

---

**修复完成时间**: 2026-01-17 02:46（代码修复）+ 03:00（配置修复）+ 03:35（429修复）+ 04:00（跟随预热）
**修复人员**: 浮浮酱 (Claude Opus 4.5)
**参考仓库**: Antigravity-Manager (Rust)
