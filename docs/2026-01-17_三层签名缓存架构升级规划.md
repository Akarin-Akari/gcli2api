# gcli2api 三层签名缓存架构升级规划

**文档创建时间**: 2026-01-17
**作者**: Claude Opus 4.5 (浮浮酱)
**目标读者**: 下一个 Claude Agent 开发者
**目的**: 指导将 gcli2api 的签名缓存架构从 2 层升级到 3 层，并实现 Tool Loop Recovery

---

## 一、背景与问题

### 1.1 当前问题

Cursor IDE 在调用工具后返回 `400 Invalid signature in thinking block` 错误。根本原因：

1. **Cursor 过滤 Thinking 块**：Cursor 不保留 assistant 消息中的 thinking 内容和 signature
2. **签名恢复失败**：当前缓存架构无法在所有场景下恢复签名
3. **工具循环断裂**：当 Thinking 块被过滤后，工具循环（Tool Loop）可能断裂

### 1.2 参考项目

- **Antigravity-Manager**：Rust 实现的三层缓存架构，有 Tool Loop Recovery 功能
- **gcli2api_official**：使用 `skip_thought_signature_validator` 占位符

### 1.3 重要发现

**Antigravity-Manager 自身也存在 400 错误问题**，说明其架构并非完美。我们需要：
- 借鉴其优秀设计
- 避免其已知缺陷
- 保持 gcli2api 的独有优势

---

## 二、架构对比

### 2.1 当前 gcli2api 架构（2 层）

```
┌─────────────────────────────────────────────────────────┐
│                   SignatureCache                         │
├─────────────────────────────────────────────────────────┤
│  Layer 1: Thinking Text Hash → (Signature, Text)        │
│           _cache: OrderedDict[str, CacheEntry]          │
│           - LRU 淘汰                                     │
│           - TTL 过期                                     │
├─────────────────────────────────────────────────────────┤
│  Layer 2: Tool ID → Signature                           │
│           _tool_signatures: Dict[str, CacheEntry]       │
│           - 已实现但未充分利用                            │
└─────────────────────────────────────────────────────────┘
```

### 2.2 Antigravity-Manager 架构（3 层）

```
┌─────────────────────────────────────────────────────────┐
│                   SignatureCache                         │
├─────────────────────────────────────────────────────────┤
│  Layer 1: Tool Use ID → Thinking Signature              │
│           tool_signatures: HashMap<String, CacheEntry>  │
├─────────────────────────────────────────────────────────┤
│  Layer 2: Signature → Model Family                      │
│           thinking_families: HashMap<String, CacheEntry>│
│           - 跨模型兼容性检查                              │
├─────────────────────────────────────────────────────────┤
│  Layer 3: Session ID → Latest Thinking Signature        │
│           session_signatures: HashMap<String, CacheEntry>│
│           - 会话级隔离                                    │
└─────────────────────────────────────────────────────────┘
```

### 2.3 目标架构（3 层 + gcli2api 特色）

```
┌─────────────────────────────────────────────────────────┐
│                   SignatureCache                         │
├─────────────────────────────────────────────────────────┤
│  Layer 1: Tool ID → Signature                           │
│           _tool_signatures: Dict[str, CacheEntry]       │
│           - 工具调用级别缓存                              │
├─────────────────────────────────────────────────────────┤
│  Layer 2: Thinking Text Hash → (Signature, Text)        │
│           _cache: OrderedDict[str, CacheEntry]          │
│           - 内容级别缓存（gcli2api 特色：配对缓存）        │
├─────────────────────────────────────────────────────────┤
│  Layer 3: Session ID → (Signature, Thinking Text)       │
│           _session_signatures: Dict[str, CacheEntry]    │
│           - 会话级别隔离                                  │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│              Tool ID 编码机制（gcli2api 独有）            │
├─────────────────────────────────────────────────────────┤
│  encode_tool_id_with_signature(tool_id, signature)      │
│  decode_tool_id_and_signature(encoded_id)               │
│  - 签名直接编码在工具ID中，客户端透明传递                  │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│              Tool Loop Recovery（新增）                  │
├─────────────────────────────────────────────────────────┤
│  analyze_conversation_state(messages)                   │
│  close_tool_loop_for_thinking(messages)                 │
│  - 检测断裂的工具循环                                     │
│  - 注入合成消息关闭循环                                   │
└─────────────────────────────────────────────────────────┘
```

---

## 三、签名恢复优先级

### 3.1 当前策略（3 层）

```
1. Client (请求自带) → 失败
2. Encoded Tool ID (从编码的工具ID解码) → 失败
3. get_last_signature_with_text() (最近缓存) → 失败
4. 禁用 Thinking 模式
```

### 3.2 目标策略（6 层）

```
1. Client (请求自带的 signature)
   ↓ 失败
2. Context (上下文中的 last_thought_signature)
   ↓ 失败
3. Encoded Tool ID (从编码的工具ID解码) ← gcli2api 独有优势
   ↓ 失败
4. Session Cache (Layer 3 - 会话级别)
   ↓ 失败
5. Tool Cache (Layer 1 - 工具ID级别)
   ↓ 失败
6. Last Signature (最近缓存的配对)
   ↓ 失败
7. 使用占位符 skip_thought_signature_validator 或禁用 Thinking
```

---

## 四、需要实现的功能

### 4.1 高优先级（P0）

#### 4.1.1 完善 Session 签名缓存

**文件**: `src/signature_cache.py`

**当前状态**: Layer 3 缓存结构已存在但未充分使用

**需要做的**:
1. 确保 `cache_session_signature()` 在响应阶段被调用
2. 确保 `get_session_signature()` 在恢复策略中被使用
3. 添加会话ID提取逻辑

**会话ID来源**:
- 请求头中的自定义字段（如 `X-Session-ID`）
- 或基于请求特征生成的指纹

#### 4.1.2 实现 Tool Loop Recovery

**文件**: 新建 `src/converters/tool_loop_recovery.py`

**功能**:
1. `analyze_conversation_state(messages)` - 分析对话状态
2. `close_tool_loop_for_thinking(messages)` - 关闭断裂的工具循环

**触发条件**:
- 最后一条消息是 ToolResult（用户角色）
- 前面的 Assistant 消息没有 Thinking 块（被过滤了）

**处理方式**:
- 注入合成的 Assistant 消息：`[System: Tool loop recovered. Previous tool execution accepted.]`
- 注入合成的 User 消息：`[Proceed]`
- 这样模型会开始新的 Thinking 轮次

#### 4.1.3 增强签名恢复策略

**文件**: `src/anthropic_converter.py` 或新建 `src/converters/signature_recovery.py`

**功能**: 实现 6 层恢复策略

### 4.2 中优先级（P1）

#### 4.2.1 在流式响应时缓存签名

**文件**: `src/antigravity_router.py` 的流式处理部分

**需要做的**:
1. 处理工具调用时，同时缓存到 Tool Cache 和 Session Cache
2. 确保缓存时机正确（在发送响应之前）

#### 4.2.2 添加缓存统计和监控

**功能**:
- 缓存命中率统计
- 各层恢复成功率统计
- 日志增强

### 4.3 低优先级（P2）

#### 4.3.1 跨模型兼容性检查

**功能**: 防止 Claude 的签名用于 Gemini 模型（如果支持多模型）

**当前状态**: gcli2api 主要用于 Antigravity API，可能不需要

---

## 五、需要避免的问题

### 5.1 Antigravity-Manager 的已知缺陷

#### 缺陷 #1: 工具ID生成不一致

**问题**: Antigravity-Manager 使用随机ID生成，导致流式响应和请求转换时ID不一致

**gcli2api 现状**: ✅ 已避免 - 使用确定性哈希生成

**注意**: 不要修改 `generate_tool_call_id()` 的实现

#### 缺陷 #2: 缺少工具ID编码机制

**问题**: Antigravity-Manager 没有将签名编码到工具ID中

**gcli2api 现状**: ✅ 已实现 - `thoughtSignature_fix.py`

**注意**: 保持并充分利用这个优势

#### 缺陷 #3: 签名恢复失败时直接跳过

**问题**: Antigravity-Manager 在所有恢复策略失败时，直接发送没有 signature 的请求

**gcli2api 现状**: ⚠️ 使用占位符 `skip_thought_signature_validator`

**建议**:
- 保持使用占位符作为最后手段
- 增强恢复策略减少失败率
- 考虑在极端情况下禁用 Thinking 模式

#### 缺陷 #4: Tool Loop Recovery 可能不够完善

**问题**: 即使 Antigravity-Manager 有 Tool Loop Recovery，仍然出现 400 错误

**可能原因**:
- 合成消息的格式不被 API 接受
- 检测逻辑有边界情况
- 签名恢复在注入消息后仍然失败

**建议**:
- 实现时添加详细日志
- 测试各种边界情况
- 考虑多种恢复策略

### 5.2 需要保持的 gcli2api 优势

1. **确定性工具ID生成** - 不要改为随机生成
2. **工具ID签名编码** - 这是核心优势，要充分利用
3. **Thinking Text 配对缓存** - 保证签名和内容匹配
4. **迁移模式支持** - 保持向后兼容

---

## 六、实现建议

### 6.1 Session ID 提取策略

由于 OpenAI 兼容格式没有标准的会话ID字段，需要自行生成：

**方案 A**: 基于请求特征生成指纹
```python
def generate_session_fingerprint(request) -> str:
    """基于请求特征生成会话指纹"""
    # 可以使用：
    # - 第一条用户消息的哈希
    # - 系统提示的哈希
    # - 请求头中的自定义字段
    pass
```

**方案 B**: 使用请求头
```python
# 客户端发送: X-Session-ID: xxx
session_id = request.headers.get("X-Session-ID")
```

**建议**: 优先使用方案 A，因为不需要客户端配合

### 6.2 Tool Loop Recovery 实现要点

**检测逻辑**:
```python
def analyze_conversation_state(messages: List[Dict]) -> ConversationState:
    """分析对话状态"""
    state = ConversationState()

    # 1. 找到最后一条 assistant 消息的索引
    # 2. 检查最后一条消息是否是 ToolResult
    # 3. 检查 assistant 消息是否有 Thinking 块

    return state
```

**恢复逻辑**:
```python
def close_tool_loop_for_thinking(messages: List[Dict]) -> None:
    """关闭断裂的工具循环"""
    state = analyze_conversation_state(messages)

    if state.in_tool_loop and not state.has_thinking:
        # 注入合成消息
        messages.append({
            "role": "assistant",
            "content": "[System: Tool loop recovered. Previous tool execution accepted.]"
        })
        messages.append({
            "role": "user",
            "content": "[Proceed]"
        })
```

**调用位置**: 在消息转换之前，`antigravity_router.py` 的请求处理阶段

### 6.3 测试要点

1. **正常工具调用流程** - 确保不影响正常功能
2. **Cursor 场景** - Thinking 块被过滤后的恢复
3. **多轮工具调用** - 连续多次工具调用
4. **会话隔离** - 不同会话不互相污染
5. **边界情况** - 空消息、格式异常等

---

## 七、文件修改清单

### 7.1 需要修改的文件

| 文件 | 修改内容 |
|------|---------|
| `src/signature_cache.py` | 完善 Session Cache 使用 |
| `src/antigravity_router.py` | 调用 Tool Loop Recovery，增强缓存逻辑 |
| `src/anthropic_converter.py` | 使用增强的签名恢复策略 |

### 7.2 需要新建的文件

| 文件 | 功能 |
|------|------|
| `src/converters/tool_loop_recovery.py` | Tool Loop 检测和恢复 |
| `src/converters/signature_recovery.py` | 统一的签名恢复策略（可选，也可以放在现有文件中） |

### 7.3 需要添加的测试

| 测试文件 | 测试内容 |
|---------|---------|
| `tests/test_tool_loop_recovery.py` | Tool Loop Recovery 功能测试 |
| `tests/test_session_cache.py` | Session Cache 隔离测试 |
| `tests/test_signature_recovery.py` | 6 层恢复策略测试 |

---

## 八、验收标准

### 8.1 功能验收

1. ✅ Cursor 工具调用不再返回 400 错误
2. ✅ Claude Code 功能不受影响
3. ✅ 多轮工具调用正常工作
4. ✅ 不同会话签名隔离

### 8.2 性能验收

1. ✅ 缓存查找延迟 < 1ms
2. ✅ 内存使用合理（有 LRU 淘汰）
3. ✅ 不影响流式响应速度

### 8.3 日志验收

1. ✅ 签名恢复来源有明确日志
2. ✅ Tool Loop Recovery 触发有日志
3. ✅ 缓存命中/未命中有统计

---

## 九、参考资料

### 9.1 相关文档

- `docs/2026-01-16_Antigravity-Manager缺陷启示与对比分析.md` - 详细的对比分析
- `docs/2026-01-09_Signature缓存架构优化研究报告.md` - 缓存架构设计
- `docs/2026-01-16_Signature与思维块处理缺陷修复开发文档_完工报告.md` - 之前的修复记录

### 9.2 相关代码

**gcli2api**:
- `src/signature_cache.py` - 签名缓存实现
- `src/converters/thoughtSignature_fix.py` - 工具ID编码机制
- `src/antigravity_router.py` - 主路由和消息处理

**Antigravity-Manager** (参考):
- `src-tauri/src/proxy/signature_cache.rs` - 三层缓存实现
- `src-tauri/src/proxy/mappers/claude/thinking_utils.rs` - Tool Loop Recovery
- `src-tauri/src/proxy/mappers/claude/request.rs` - 签名恢复策略

---

## 十、总结

### 10.1 核心任务

1. **完善三层缓存架构** - 充分利用已有的 Session Cache
2. **实现 Tool Loop Recovery** - 处理 Thinking 块被过滤的场景
3. **增强签名恢复策略** - 从 3 层提升到 6 层

### 10.2 关键原则

1. **保持现有优势** - 确定性ID生成、工具ID编码机制
2. **避免已知缺陷** - 不要复制 Antigravity-Manager 的错误
3. **渐进式改进** - 先实现核心功能，再优化细节

### 10.3 预期效果

- Cursor 工具调用成功率显著提升
- 签名恢复成功率从约 70% 提升到 95%+
- 工具循环断裂问题得到解决

---

**文档结束**

祝下一个 Claude Agent 开发顺利喵～ ฅ'ω'ฅ
