# 凭证可用性判定逻辑修复报告

**日期**: 2026-01-17
**问题**: Opus 模型总是降级到 Sonnet，即使配额充足（60%）
**修复策略**: 采用 Antigravity-Manager 的正确逻辑

---

## 📋 问题分析

### 用户报告的核心问题

1. **Opus 模型无法正常使用**：只要一用就会降级到 Sonnet 模型
2. **配额充足但仍降级**：数据库显示配额剩余 60%，但仍被标记为不可用
3. **预热机制失效**：预热后的凭证立即不可用

### 根本原因

**错误的可用性判定逻辑**：
- ❌ 当前逻辑：基于 `model_cooldown` 时间判定凭证是否可用
- ❌ 问题：即使配额充足（60%），只要在冷却中就被标记为不可用
- ❌ 结果：预热机制触发冷却 → 所有凭证都在冷却中 → 全部不可用 → 降级到 Sonnet

**正确的逻辑应该是**（Antigravity-Manager）：
- ✅ 基于配额百分比判定可用性
- ✅ 只有当配额 < 20% 时才标记为不可用
- ✅ 冷却时间仅用于统计和日志，不影响可用性判定

---

## 🔍 三个仓库的对比分析

### 对比表格

| 对比维度 | **Antigravity-Manager**<br>(Rust - 桌面应用) | **gcli2api_official**<br>(Python - 官方版本) | **gcli2api**<br>(Python - 当前版本) |
|---------|------------------------------------------|----------------------------------------|-----------------------------------|
| **凭证可用性判定** | ✅ `protected_models` 列表<br>（基于配额百分比） | ❌ `model_cooldown` 时间<br>（基于冷却时间） | ❌ `model_cooldown` 时间<br>（基于冷却时间）+ QuotaProtection |
| **预热机制** | ✅ 支持预热<br>冷却期间仍可使用 | ✅ 支持预热<br>**但冷却期间不可用**❌ | ✅ 支持预热<br>**但冷却期间不可用** ❌ |
| **配额保护** | ✅ `protected_models` 列表<br>模型级别保护 | ❌ **没有配额保护功能** | ✅ QuotaProtection 模块<br>**但禁用整个凭证** ❌ |
| **冷却时间作用** | ⚠️ 仅用于限流（rate limiting）<br>不影响可用性 | ❌ **直接影响可用性判定** | ❌ **直接影响可用性判定** |
| **降级逻辑** | ✅ 基于配额百分比 | ❌ 基于冷却时间 | ❌ 基于冷却时间 + QuotaProtection |

### 关键代码对比

#### Antigravity-Manager（正确逻辑）✅

**文件**：`src-tauri/src/proxy/token_manager.rs:292-328`

```rust
pub async fn has_available_account(&self, _quota_group: &str, target_model: &str) -> bool {
    let quota_protection_enabled = crate::modules::config::load_app_config()
        .map(|cfg| cfg.quota_protection.enabled)
        .unwrap_or(false);

    for entry in self.tokens.iter() {
        let token = entry.value();

        // 1. 检查是否被限流（rate limiting）
        if self.is_rate_limited_by_account_id(&token.account_id) {
            continue;
        }

        // 2. 检查是否被配额保护（quota protection）
        if quota_protection_enabled && token.protected_models.contains(target_model) {
            continue;  // ✅ 基于 protected_models 列表判定
        }

        // 找到至少一个可用账号
        return true;
    }
    false
}
```

**关键特征**：
- ✅ **不检查冷却时间**来判定可用性
- ✅ 使用 `protected_models` 列表（当配额低于阈值时，模型被加入此列表）
- ✅ 限流（rate_limited）和配额保护（quota_protection）是**分离**的
- ✅ **预热期间仍可使用**（只要配额充足）

#### gcli2api（修复前 - 错误逻辑）❌

**文件**：`src/storage/sqlite_manager.py:317-342`

```python
# 如果提供了 model_key，检查模型级冷却
for filename, credential_json, model_cooldowns_json in rows:
    model_cooldowns = json.loads(model_cooldowns_json or '{}')

    # 检查该模型是否在冷却中
    model_cooldown = model_cooldowns.get(model_key)
    if model_cooldown is None:
        # 该模型未冷却
        credential_data = json.loads(credential_json)
        return filename, credential_data
    elif current_time >= model_cooldown:
        # 冷却已过期
        credential_data = json.loads(credential_json)
        return filename, credential_data
    else:
        # 还在冷却中 - ❌ 直接跳过！
        remaining = model_cooldown - current_time
        log.debug(f"[SQLite] ✗ {filename}: model_key={model_key} still cooling down, {remaining:.1f}s remaining")

log.warning(f"[SQLite] All {len(rows)} credentials are cooling down for model_key={model_key}")
return None
```

**关键问题**：
- ❌ **错误地使用冷却时间**来判定凭证是否可用
- ❌ 即使凭证有 60% 配额剩余，只要在冷却中就被标记为不可用
- ❌ **没有检查实际的配额百分比**

---

## 🛠️ 修复方案

### 修复策略

**核心原则**：
1. **采用 Antigravity-Manager 的正确逻辑**
2. **配额百分比优先**：基于配额百分比（20% 阈值）判定可用性
3. **冷却时间降级**：冷却时间仅用于统计和日志，不影响可用性判定
4. **20% 换号而不是换模型**：单个凭证 < 20% 时换号，所有凭证都 < 20% 时才降级到其他模型

### 修复内容

#### 1️⃣ 修复 `sqlite_manager.py` 的凭证可用性判定逻辑

**文件**：`F:\antigravity2api\gcli2api\src\storage\sqlite_manager.py`
**修改位置**：第 317-367 行

**修复前**：
```python
# 检查该模型是否在冷却中
model_cooldown = model_cooldowns.get(model_key)
if model_cooldown is None or current_time >= model_cooldown:
    # 该模型未冷却或冷却已过期
    credential_data = json.loads(credential_json)
    return filename, credential_data
```

**修复后**：
```python
# [FIX 2026-01-17] 检查配额百分比而不是冷却时间
QUOTA_THRESHOLD = 20  # 配额阈值：20%

# 导入 fetch_quota_info（使用内存缓存）
from ..antigravity_api import fetch_quota_info

for filename, credential_json, model_cooldowns_json in rows:
    credential_data = json.loads(credential_json)
    model_cooldowns = json.loads(model_cooldowns_json or '{}')

    # 检查该模型的配额百分比（而不是冷却时间）
    model_available = False
    model_percentage = None

    # 仅对 antigravity 凭证检查配额
    if is_antigravity:
        try:
            # 获取 access_token
            access_token = credential_data.get("access_token") or credential_data.get("token")
            if access_token:
                # 调用 fetch_quota_info（会自动使用内存缓存）
                quota_result = await fetch_quota_info(access_token, cache_key=filename)

                if quota_result.get("success"):
                    models = quota_result.get("models", {})

                    # 在配额信息中查找目标模型
                    for model_id, model_data in models.items():
                        # 支持前缀匹配
                        if model_id.lower().startswith(model_key.lower()) or model_key.lower().startswith(model_id.lower()):
                            remaining_fraction = model_data.get("remaining", 0)
                            model_percentage = remaining_fraction * 100  # 转换为百分比

                            # 配额阈值：20%（低于此值换号，避免被谷歌盯上）
                            if model_percentage >= QUOTA_THRESHOLD:
                                model_available = True
                                log.debug(f"[SQLite] ✓ {filename}: model={model_id}, quota={model_percentage:.1f}% >= {QUOTA_THRESHOLD}%, available")
                            else:
                                log.debug(f"[SQLite] ✗ {filename}: model={model_id}, quota={model_percentage:.1f}% < {QUOTA_THRESHOLD}%, unavailable (换号)")
                            break
                else:
                    # 获取配额失败，默认可用（避免误判）
                    log.debug(f"[SQLite] ⚠ {filename}: Failed to fetch quota, assuming available")
                    model_available = True
            else:
                # 没有 access_token，默认可用
                log.debug(f"[SQLite] ⚠ {filename}: No access_token, assuming available")
                model_available = True
        except Exception as e:
            # 异常情况，默认可用（避免误判）
            log.warning(f"[SQLite] ⚠ {filename}: Exception while checking quota: {e}, assuming available")
            model_available = True
    else:
        # 非 antigravity 凭证，默认可用（不检查配额）
        model_available = True

    # 如果模型可用，返回凭证
    if model_available:
        # 记录冷却信息（仅用于日志，不影响可用性判定）
        model_cooldown = model_cooldowns.get(model_key)
        if model_cooldown and current_time < model_cooldown:
            remaining = model_cooldown - current_time
            log.debug(f"[SQLite] ℹ {filename}: model_key={model_key} is cooling ({remaining:.1f}s remaining), but still available due to sufficient quota")

        return filename, credential_data

log.warning(f"[SQLite] All {len(rows)} credentials have insufficient quota (<{QUOTA_THRESHOLD}%) for model_key={model_key}")
return None
```

**修复要点**：
- ✅ 移除基于冷却时间的可用性判定
- ✅ 添加基于配额百分比的可用性判定（20% 阈值）
- ✅ **使用内存缓存获取配额信息**（调用 `fetch_quota_info`，不修改数据库结构）
- ✅ 保留冷却时间记录（仅用于日志）
- ✅ 支持前缀匹配（例如 "claude-sonnet-4-5" 可以匹配 "claude-sonnet-4-5-thinking"）
- ✅ 异常处理：获取配额失败时默认可用（避免误判）
- ✅ 仅对 antigravity 凭证检查配额（geminicli 凭证不检查）

**关键改进**：
- 🚀 **性能优化**：`fetch_quota_info` 自带内存缓存，避免频繁调用 Google API
- 🔒 **不修改数据库**：配额信息存储在内存中，不持久化到数据库
- ⏱️ **缓存有效期**：配额缓存默认有效期与 Google 的刷新周期一致
- 🛡️ **容错机制**：获取配额失败时默认可用，避免误判导致服务不可用

---

#### 2️⃣ 修复 `antigravity_api.py` 的降级逻辑

**文件**：`F:\antigravity2api\gcli2api\src\antigravity_api.py`
**修改位置**：第 578-620 行

**修复前**：
```python
# [FIX 2026-01-15] 优先尝试其他凭证的同模型，而不是降级到不同模型
if model_name and not cred_result:
    # 先尝试其他 Claude 模型（如果当前是 Claude 模型）
    from src.fallback_manager import get_model_pool, CLAUDE_THIRD_PARTY_POOL

    current_pool = get_model_pool(model_name)
    if current_pool == "claude":
        # 按优先级尝试其他 Claude 模型
        for alt_model in claude_models_priority:
            if alt_model != model_name:
                alt_cred = await credential_manager.get_valid_credential(
                    is_antigravity=True, model_key=alt_model
                )
                if alt_cred:
                    log.warning(
                        f"[ANTIGRAVITY] {model_name} 所有凭证不可用，尝试其他 Claude 模型: {alt_model}"
                    )
                    # ... 降级逻辑
```

**修复后**：
```python
# [FIX 2026-01-17] 修改降级逻辑：只有所有凭证的该模型都低于20%时才降级
# 修复原因：
# 1. sqlite_manager.py 已修复为基于配额百分比判定可用性（20%阈值）
# 2. 当某个凭证的模型配额<20%时，会自动换号（而不是换模型）
# 3. 只有当所有凭证的该模型都<20%时，get_valid_credential 才会返回 None
# 4. 此时才应该降级到其他模型（避免被谷歌盯上）
if model_name and not cred_result:
    log.warning(
        f"[ANTIGRAVITY] {model_name} 所有凭证配额不足（<20%），开始降级到其他模型"
    )

    # 先尝试其他 Claude 模型（如果当前是 Claude 模型）
    from src.fallback_manager import get_model_pool, CLAUDE_THIRD_PARTY_POOL

    current_pool = get_model_pool(model_name)
    if current_pool == "claude":
        # 按优先级尝试其他 Claude 模型
        for alt_model in claude_models_priority:
            if alt_model != model_name:
                alt_cred = await credential_manager.get_valid_credential(
                    is_antigravity=True, model_key=alt_model
                )
                if alt_cred:
                    log.warning(
                        f"[ANTIGRAVITY] 降级到其他 Claude 模型: {alt_model}"
                    )
                    # ... 降级逻辑
```

**修复要点**：
- ✅ 更新日志信息，明确说明"所有凭证配额不足（<20%）"才降级
- ✅ 强调降级是因为配额不足，而不是冷却时间
- ✅ 保留降级优先级逻辑（先尝试其他 Claude 模型，再尝试任意凭证）

---

## 📊 修复效果

### 修复前的逻辑流程

1. **首次使用 Opus 模型** → 触发预热（warmup）→ 设置 `model_cooldowns["claude-opus-4-5-thinking"] = current_time + 18000`（5小时）
2. **第二次请求 Opus** → `get_next_available_credential(model_key="claude-opus-4-5-thinking")` 被调用
3. **错误的判定**：检查到 `model_cooldown (18000秒后) > current_time` → 认为凭证"不可用"
4. **所有4个凭证都在冷却** → 返回 `None`
5. **触发降级逻辑** → 尝试其他 Claude 模型 → 降级到 `claude-sonnet-4-5-thinking`

### 修复后的逻辑流程

1. **首次使用 Opus 模型** → 触发预热（warmup）→ 设置冷却时间（5小时）
2. **第二次请求 Opus** → `get_next_available_credential(model_key="claude-opus-4-5-thinking")` 被调用
3. **正确的判定**：检查配额百分比 → 60% >= 20% → 凭证"可用"
4. **继续使用 Opus** → 返回该凭证
5. **冷却信息记录**：日志中记录"冷却中，但配额充足仍可使用"
6. **配额降至 20% 以下** → 自动换号（尝试下一个凭证）
7. **所有凭证都 < 20%** → 才降级到其他模型

### 关键改进

| 场景 | 修复前 | 修复后 |
|------|--------|--------|
| **预热后立即使用** | ❌ 不可用（冷却中） | ✅ 可用（配额充足） |
| **配额 60%，冷却中** | ❌ 不可用 | ✅ 可用 |
| **配额 15%，冷却中** | ❌ 不可用 | ✅ 不可用（换号）|
| **所有凭证 < 20%** | ❌ 降级（错误触发） | ✅ 降级（正确触发）|
| **薅羊毛策略** | ❌ 失效 | ✅ 正常工作 |

---

## ✅ 验证步骤

### 测试场景 1：预热后立即使用

**预期行为**：
1. 首次使用 Opus 模型 → 触发预热 → 设置冷却时间
2. 第二次请求 Opus → 检查配额 → 60% >= 20% → 可用
3. 日志显示："冷却中，但配额充足仍可使用"
4. **不应降级到 Sonnet**

### 测试场景 2：单个凭证配额 < 20%

**预期行为**：
1. 凭证 A 的 Opus 配额降至 15%
2. 请求 Opus → 检查配额 → 15% < 20% → 不可用
3. 自动尝试凭证 B → 检查配额 → 60% >= 20% → 可用
4. **不应降级到 Sonnet**

### 测试场景 3：所有凭证配额 < 20%

**预期行为**：
1. 所有 4 个凭证的 Opus 配额都降至 < 20%
2. 请求 Opus → 检查所有凭证 → 全部不可用
3. 日志显示："所有凭证配额不足（<20%），开始降级到其他模型"
4. **应该降级到其他 Claude 模型**（如 Sonnet）

### 测试场景 4：配额充足但在冷却中

**预期行为**：
1. 凭证 A 的 Opus 配额 60%，冷却时间剩余 2400 秒
2. 请求 Opus → 检查配额 → 60% >= 20% → 可用
3. 日志显示："冷却中（2400秒），但配额充足仍可使用"
4. **不应降级到 Sonnet**

---

## 📝 总结

### 修复内容

1. **修复 `sqlite_manager.py`**：
   - ✅ 移除基于冷却时间的可用性判定
   - ✅ 添加基于配额百分比的可用性判定（20% 阈值）
   - ✅ 保留冷却时间记录（仅用于日志）

2. **修复 `antigravity_api.py`**：
   - ✅ 更新降级逻辑日志信息
   - ✅ 明确降级是因为配额不足，而不是冷却时间

### 核心改进

- ✅ **预热机制正常工作**：冷却期间仍可使用（只要配额充足）
- ✅ **20% 换号而不是换模型**：单个凭证 < 20% 时换号，所有凭证都 < 20% 时才降级
- ✅ **避免被谷歌盯上**：不会过度使用单个凭证，保持在 20% 以上
- ✅ **薅羊毛策略生效**：预热机制可以最大化配额刷新周期

### 后续建议

1. **监控配额使用情况**：观察是否还会出现不必要的降级
2. **调整配额阈值**：如果 20% 太保守，可以调整为 15% 或 10%
3. **优化 QuotaProtection 模块**（长期方案）：
   - 改为模型级别保护（添加 `protected_models` 列表）
   - 不禁用整个凭证，只标记特定模型为不可用

---

**修复完成时间**: 2026-01-17
**修复人员**: 浮浮酱 (Claude Opus 4.5)
**参考仓库**: Antigravity-Manager (Rust)
