# 6层签名恢复策略全部失败根因分析报告

**日期**: 2026-01-17
**问题**: Claude Code 中工具调用丢失签名，6层恢复策略全部失败
**严重程度**: P0 Critical
**分析者**: Claude Sonnet 4.5 (浮浮酱)

---

## 一、问题现象

用户报告在实现了 6 层签名缓存架构后，Claude Code 反而出现了丢工具 ID 的状况：

```
[08:09:44] [WARNING] [SIGNATURE_RECOVERY] All 6 layers failed for tool_id=call_644a6dbd0d0afb79a8c04e9f
[08:09:44] [WARNING] [ANTHROPIC CONVERTER] No signature found for tool call: call_644a6dbd0d0afb79a8c04e9f, using placeholder
```

从日志中可以看到，大量工具调用的签名恢复失败，所有 6 层策略都无法找到有效的签名。

---

## 二、根因分析

### 2.1 核心问题：函数重复定义导致模块未被调用

经过深入分析，我发现了**致命的架构缺陷**：

#### 问题 1: `anthropic_converter.py` 中存在本地的 `recover_signature_for_tool_use` 函数

**位置**: `F:\antigravity2api\gcli2api\src\anthropic_converter.py:424-484`

```python
def recover_signature_for_tool_use(
    tool_id: str,
    encoded_tool_id: str,
    signature: Optional[str],
    last_thought_signature: Optional[str],
    session_id: Optional[str] = None
) -> Optional[str]:
    """
    多层签名恢复策略（用于工具调用）- 6层完整实现

    优先级：
    1. 客户端提供的签名
    2. 上下文中的签名
    3. 从编码的工具ID中解码（自研版特有）
    4. 会话级缓存 [FIX 2026-01-17] 已启用
    5. 工具ID缓存
    6. 最近签名（fallback）
    """
    from src.signature_cache import (
        get_tool_signature,
        get_last_signature,
        get_session_signature
    )

    # ... 实现代码
```

#### 问题 2: `signature_recovery.py` 中存在**同名但参数不同**的函数

**位置**: `F:\antigravity2api\gcli2api\src\converters\signature_recovery.py:183-278`

```python
def recover_signature_for_tool_use(
    tool_id: str,
    encoded_tool_id: str,
    client_signature: Optional[str] = None,
    context_signature: Optional[str] = None,
    session_id: Optional[str] = None,
    use_placeholder_fallback: bool = True
) -> RecoveryResult:
    """
    为工具调用恢复签名（6层策略）

    Args:
        tool_id: 原始工具调用ID
        encoded_tool_id: 编码的工具调用ID（可能包含签名）
        client_signature: 客户端提供的签名
        context_signature: 上下文中的签名
        session_id: 会话ID
        use_placeholder_fallback: 是否在所有策略失败时使用占位符

    Returns:
        RecoveryResult: 恢复结果
    """
    # ... 实现代码
```

### 2.2 关键差异对比

| 特性 | `anthropic_converter.py` 版本 | `signature_recovery.py` 版本 |
|------|------------------------------|------------------------------|
| **参数签名** | `signature`, `last_thought_signature` | `client_signature`, `context_signature` |
| **返回类型** | `Optional[str]` | `RecoveryResult` (数据类) |
| **占位符处理** | 返回 `None` | 返回 `RecoveryResult` 包含占位符 |
| **日志级别** | 使用 `log.debug` / `log.info` | 使用 `RecoverySource` 枚举 |
| **模块化** | 内联实现，直接导入缓存函数 | 模块化设计，使用 `RecoveryResult` |

### 2.3 调用位置分析

**在 `anthropic_converter.py:774` 调用**:

```python
final_sig = recover_signature_for_tool_use(
    tool_id=original_id,
    encoded_tool_id=encoded_id,
    signature=thoughtsignature,  # ❌ 错误：参数名不匹配
    last_thought_signature=None,  # ❌ 错误：参数名不匹配
    session_id=session_id
)
```

**问题**：
1. 调用的是**本地定义的函数**，而不是 `signature_recovery.py` 中的模块化版本
2. 参数名 `signature` 和 `last_thought_signature` 与 `signature_recovery.py` 中的 `client_signature` 和 `context_signature` 不匹配
3. 返回值是 `Optional[str]`，而不是 `RecoveryResult`

### 2.4 为什么 6 层策略全部失败？

让我逐层分析失败原因：

#### Layer 1: Client signature - 为什么没有？

**代码**: `anthropic_converter.py:449-451`

```python
if signature and len(signature) >= MIN_SIGNATURE_LENGTH:
    log.debug(f"[SIGNATURE_RECOVERY] Layer 1: Client signature for tool_id={tool_id}")
    return signature
```

**失败原因**:
- `signature` 参数来自 `thoughtsignature`，它是从 `decode_tool_id_and_signature(encoded_id)` 解码得到的
- 但是，**Claude Code 发送的工具调用 ID 是原始的 `call_xxx` 格式，没有编码签名**
- 因此 `thoughtsignature` 为空，Layer 1 失败

#### Layer 2: Context signature - 为什么没有？

**代码**: `anthropic_converter.py:454-456`

```python
if last_thought_signature and len(last_thought_signature) >= MIN_SIGNATURE_LENGTH:
    log.debug(f"[SIGNATURE_RECOVERY] Layer 2: Context signature for tool_id={tool_id}")
    return last_thought_signature
```

**失败原因**:
- `last_thought_signature` 参数在调用时传入的是 `None`
- 注释说明："工具调用通常不直接关联上下文中的 thinking"
- 因此 Layer 2 失败

#### Layer 3: Encoded Tool ID - 为什么解码失败？

**代码**: `anthropic_converter.py:459-462`

```python
_, decoded_sig = decode_tool_id_and_signature(encoded_tool_id)
if decoded_sig and len(decoded_sig) >= MIN_SIGNATURE_LENGTH:
    log.debug(f"[SIGNATURE_RECOVERY] Layer 3: Decoded from encoded tool_id={tool_id}")
    return decoded_sig
```

**失败原因**:
- `encoded_tool_id` 是 `encoded_id`，它来自 `item.get("id")`
- **Claude Code 发送的工具调用 ID 是原始的 `call_xxx` 格式，没有编码签名**
- `decode_tool_id_and_signature` 无法从原始 ID 中解码出签名
- 因此 Layer 3 失败

#### Layer 4: Session Cache - 为什么没有命中？

**代码**: `anthropic_converter.py:465-469`

```python
if session_id:
    session_sig = get_session_signature(session_id)
    if session_sig and len(session_sig) >= MIN_SIGNATURE_LENGTH:
        log.debug(f"[SIGNATURE_RECOVERY] Layer 4: Session cache hit for tool_id={tool_id}")
        return session_sig
```

**失败原因**:
- `session_id` 是通过 `generate_session_fingerprint(messages)` 生成的
- 但是，**Session 签名缓存的写入时机有问题**
- 查看日志，发现 Session 签名缓存只在 `antigravity_router.py:370` 写入（流式响应中）
- 但是，**请求阶段**（`anthropic_converter.py`）执行时，Session 缓存可能还没有被写入
- 因此 Layer 4 失败

#### Layer 5: Tool Cache - 为什么没有命中？

**代码**: `anthropic_converter.py:472-475`

```python
tool_sig = get_tool_signature(tool_id)
if tool_sig and len(tool_sig) >= MIN_SIGNATURE_LENGTH:
    log.debug(f"[SIGNATURE_RECOVERY] Layer 5: Tool cache hit for tool_id={tool_id}")
    return tool_sig
```

**失败原因**:
- 查看日志，发现工具签名缓存写入的日志很少：
  ```
  [STREAMING] Cached tool signature: tool_id=call_xxx
  ```
- 工具签名缓存的写入位置：
  1. `antigravity_router.py:622` - 流式响应中
  2. `anthropic_converter.py:767` - 请求转换中
- **关键问题**：工具签名缓存的写入发生在**响应阶段**，但恢复发生在**请求阶段**
- **时序问题**：
  - 第一轮对话：响应中缓存工具签名 → 下一轮请求可以恢复
  - 但是，**第一轮请求时缓存是空的**，所以 Layer 5 失败

#### Layer 6: Last Signature - 为什么没有？

**代码**: `anthropic_converter.py:478-481`

```python
last_sig = get_last_signature()
if last_sig and len(last_sig) >= MIN_SIGNATURE_LENGTH:
    log.info(f"[SIGNATURE_RECOVERY] Layer 6: Using last signature as fallback for tool_id={tool_id}")
    return last_sig
```

**失败原因**:
- `get_last_signature()` 从 `_cache` 中获取最近缓存的签名
- 查看日志，发现 thinking 签名缓存写入成功：
  ```
  [SIGNATURE_CACHE] Antigravity 流式响应缓存写入成功: thinking_len=xxx
  ```
- **但是**，`get_last_signature()` 返回的是 **thinking 签名**，而不是**工具调用签名**
- **关键问题**：thinking 签名和工具调用签名是**不同的**
- 使用 thinking 签名作为工具调用签名会导致签名不匹配
- 因此 Layer 6 失败（即使有签名，也不能用）

---

## 三、为什么会出现这个问题？

### 3.1 架构演进历史

1. **最初版本** (`anthropic_converter.py`):
   - 直接在 `anthropic_converter.py` 中实现签名恢复逻辑
   - 简单的 6 层 if-else 判断
   - 返回 `Optional[str]`

2. **模块化重构** (`signature_recovery.py`):
   - 将签名恢复逻辑提取到独立模块
   - 引入 `RecoveryResult` 数据类
   - 引入 `RecoverySource` 枚举
   - 提供更详细的日志和统计

3. **问题产生**:
   - 重构后，**忘记删除** `anthropic_converter.py` 中的旧实现
   - 导致两个同名函数共存
   - Python 的作用域规则：**本地函数优先于导入的函数**
   - 因此，调用的是旧版本的函数，而不是新版本

### 3.2 为什么没有被发现？

1. **没有导入冲突警告**:
   - `anthropic_converter.py` 没有导入 `signature_recovery.py` 中的 `recover_signature_for_tool_use`
   - 因此没有名称冲突警告

2. **参数兼容性**:
   - 旧版本的参数 `signature` 和 `last_thought_signature` 可以接受任何值
   - 调用时不会报错，只是逻辑不正确

3. **返回值兼容性**:
   - 旧版本返回 `Optional[str]`
   - 调用方期望的也是 `Optional[str]`
   - 因此没有类型错误

4. **日志混淆**:
   - 两个版本都使用 `[SIGNATURE_RECOVERY]` 前缀
   - 难以区分是哪个版本在运行

---

## 四、签名缓存写入时机分析

### 4.1 Thinking 签名缓存写入

**位置**: `antigravity_router.py:356-365`

```python
if state["current_thinking_text"] and state["current_thinking_signature"]:
    success = cache_signature(
        state["current_thinking_text"],
        state["current_thinking_signature"],
        model=model
    )
    if success:
        log.info(f"[SIGNATURE_CACHE] Antigravity 流式响应缓存写入成功: "
                f"thinking_len={len(state['current_thinking_text'])}, model={model}")
```

**时机**: 流式响应中，thinking block 结束时（`flush_thinking_buffer`）

**状态**: ✅ 正常工作

### 4.2 Session 签名缓存写入

**位置**: `antigravity_router.py:370-377`

```python
if state.get("session_id"):
    try:
        cache_session_signature(
            state["session_id"],
            state["current_thinking_signature"],
            state["current_thinking_text"]
        )
        log.debug(f"[SIGNATURE_CACHE] Session cache updated: session_id={state['session_id'][:16]}...")
    except Exception as e:
        log.warning(f"[SIGNATURE_CACHE] Session cache update failed: {e}")
```

**时机**: 流式响应中，thinking block 结束时

**问题**:
- Session ID 生成依赖于请求消息
- 但是，**请求阶段**执行时，Session 缓存可能还没有被写入
- **时序问题**：请求 → 响应 → 缓存写入 → 下一轮请求才能恢复

### 4.3 工具签名缓存写入

**位置 1**: `antigravity_router.py:622-625`

```python
if state.get("current_thinking_signature"):
    tool_id = fc.get("id") or tool_call.get("id", "")
    if tool_id:
        try:
            cache_tool_signature(tool_id, state["current_thinking_signature"])
            log.info(f"[SIGNATURE_CACHE] Tool signature cached: tool_id={tool_id}")
        except Exception as e:
            log.warning(f"[SIGNATURE_CACHE] Tool signature cache failed: {e}")
```

**时机**: 流式响应中，收到工具调用时

**位置 2**: `anthropic_converter.py:767-770`

```python
if thoughtsignature and len(thoughtsignature) >= MIN_SIGNATURE_LENGTH:
    from src.signature_cache import cache_tool_signature
    try:
        cache_tool_signature(original_id, thoughtsignature)
        log.debug(f"[ANTHROPIC CONVERTER] Cached tool signature for id: {original_id}")
    except Exception as e:
        log.warning(f"[SIGNATURE_CACHE] 工具ID签名缓存失败: {e}")
```

**时机**: 请求转换中，处理 `tool_use` 消息时

**问题**:
- **位置 1** 的缓存写入依赖于 `state["current_thinking_signature"]`
- 但是，工具调用可能在 thinking block 之后，此时 `current_thinking_signature` 可能已经被重置
- **位置 2** 的缓存写入依赖于 `thoughtsignature`，它来自解码的工具 ID
- 但是，**Claude Code 发送的工具 ID 是原始格式，没有编码签名**
- 因此，两个位置的缓存写入都可能失败

---

## 五、修复方案

### 5.1 立即修复（P0 Critical）

#### 修复 1: 删除 `anthropic_converter.py` 中的重复函数

**操作**:
1. 删除 `anthropic_converter.py:424-484` 的 `recover_signature_for_tool_use` 函数
2. 从 `signature_recovery.py` 导入正确的版本
3. 修改调用代码以适配新的参数签名

**修改位置**: `anthropic_converter.py:774-780`

**修改前**:
```python
final_sig = recover_signature_for_tool_use(
    tool_id=original_id,
    encoded_tool_id=encoded_id,
    signature=thoughtsignature,
    last_thought_signature=None,
    session_id=session_id
)
```

**修改后**:
```python
from src.converters.signature_recovery import recover_signature_for_tool_use

recovery_result = recover_signature_for_tool_use(
    tool_id=original_id,
    encoded_tool_id=encoded_id,
    client_signature=thoughtsignature,
    context_signature=None,  # 可以从上下文中获取
    session_id=session_id,
    use_placeholder_fallback=True
)

final_sig = recovery_result.signature if recovery_result.success else None
```

#### 修复 2: 修复工具签名缓存的时序问题

**问题**: 工具签名缓存写入发生在响应阶段，但恢复发生在请求阶段

**方案**: 在请求转换阶段，**提前缓存**历史消息中的工具签名

**修改位置**: `anthropic_converter.py:760-770`

**修改前**:
```python
# [FIX 2026-01-17] 缓存工具ID签名 (Layer 1)
if thoughtsignature and len(thoughtsignature) >= MIN_SIGNATURE_LENGTH:
    from src.signature_cache import cache_tool_signature
    try:
        cache_tool_signature(original_id, thoughtsignature)
        log.debug(f"[ANTHROPIC CONVERTER] Cached tool signature for id: {original_id}")
    except Exception as e:
        log.warning(f"[SIGNATURE_CACHE] 工具ID签名缓存失败: {e}")
```

**修改后**:
```python
# [FIX 2026-01-17] 缓存工具ID签名 (Layer 1)
# 关键：即使 thoughtsignature 为空，也尝试从其他来源恢复并缓存
if not thoughtsignature or len(thoughtsignature) < MIN_SIGNATURE_LENGTH:
    # 尝试从恢复策略中获取签名
    from src.converters.signature_recovery import recover_signature_for_tool_use
    recovery_result = recover_signature_for_tool_use(
        tool_id=original_id,
        encoded_tool_id=encoded_id,
        client_signature=thoughtsignature,
        context_signature=None,
        session_id=session_id,
        use_placeholder_fallback=False  # 不使用占位符
    )
    if recovery_result.success and not recovery_result.is_placeholder:
        thoughtsignature = recovery_result.signature
        log.info(f"[ANTHROPIC CONVERTER] Recovered signature for tool_id: {original_id}, source: {recovery_result.source.value}")

# 缓存签名（如果有）
if thoughtsignature and len(thoughtsignature) >= MIN_SIGNATURE_LENGTH:
    from src.signature_cache import cache_tool_signature
    try:
        cache_tool_signature(original_id, thoughtsignature)
        log.debug(f"[ANTHROPIC CONVERTER] Cached tool signature for id: {original_id}")
    except Exception as e:
        log.warning(f"[SIGNATURE_CACHE] 工具ID签名缓存失败: {e}")
```

#### 修复 3: 增强 Layer 6 (Last Signature) 的安全性

**问题**: Layer 6 使用 thinking 签名作为工具调用签名，可能导致签名不匹配

**方案**:
1. 区分 thinking 签名和工具签名的缓存
2. `get_last_signature()` 只返回工具签名
3. 或者，完全禁用 Layer 6（因为风险太高）

**修改位置**: `signature_recovery.py:257-264`

**修改前**:
```python
# 优先级 6: 最近缓存的签名（fallback）
last_sig = get_last_signature()
if is_valid_signature(last_sig):
    log.info(f"[SIGNATURE_RECOVERY] Tool Layer 6: Using last cached signature for tool_id={tool_id}")
    return RecoveryResult(
        signature=last_sig,
        source=RecoverySource.LAST_SIGNATURE
    )
```

**修改后**:
```python
# 优先级 6: 最近缓存的签名（fallback）
# [FIX 2026-01-17] 禁用 Layer 6，因为使用 thinking 签名作为工具签名风险太高
# last_sig = get_last_signature()
# if is_valid_signature(last_sig):
#     log.info(f"[SIGNATURE_RECOVERY] Tool Layer 6: Using last cached signature for tool_id={tool_id}")
#     return RecoveryResult(
#         signature=last_sig,
#         source=RecoverySource.LAST_SIGNATURE
#     )
log.debug(f"[SIGNATURE_RECOVERY] Tool Layer 6: Disabled (too risky to use thinking signature for tool)")
```

### 5.2 中期优化（P1）

#### 优化 1: 实现工具签名的独立缓存

**目标**: 将工具签名和 thinking 签名分开缓存

**方案**:
1. 在 `SignatureCache` 中添加 `_tool_last_signature` 字段
2. `cache_tool_signature` 更新 `_tool_last_signature`
3. `get_last_signature()` 添加 `signature_type` 参数，区分 thinking 和 tool

#### 优化 2: 实现签名的双向绑定

**目标**: thinking 签名和工具签名建立关联

**方案**:
1. 在流式响应中，记录 thinking 签名和后续工具调用的关联
2. 在缓存中存储 `thinking_signature -> [tool_ids]` 映射
3. 恢复时，如果工具签名缺失，可以从关联的 thinking 签名恢复

#### 优化 3: 实现签名的持久化存储

**目标**: 签名缓存在服务重启后仍然有效

**方案**:
1. 使用 SQLite 存储签名缓存
2. 启动时加载历史签名
3. 定期清理过期签名

### 5.3 长期改进（P2）

#### 改进 1: 实现签名的主动预热

**目标**: 在请求发送前，主动缓存所有可能需要的签名

**方案**:
1. 在请求转换阶段，扫描所有历史消息
2. 提取所有 thinking 和 tool_use 的签名
3. 批量写入缓存

#### 改进 2: 实现签名的版本管理

**目标**: 支持签名格式的演进

**方案**:
1. 为签名添加版本号
2. 支持多版本签名共存
3. 自动迁移旧版本签名

---

## 六、验证计划

### 6.1 单元测试

1. 测试 `recover_signature_for_tool_use` 的 6 层策略
2. 测试签名缓存的写入和读取
3. 测试签名恢复的时序正确性

### 6.2 集成测试

1. 测试完整的请求-响应流程
2. 测试多轮对话中的签名传递
3. 测试工具调用的签名恢复

### 6.3 回归测试

1. 测试现有功能不受影响
2. 测试性能没有明显下降
3. 测试日志输出正确

---

## 七、总结

### 7.1 根本原因

1. **架构缺陷**: 两个同名函数共存，导致调用了错误的版本
2. **时序问题**: 签名缓存写入发生在响应阶段，但恢复发生在请求阶段
3. **设计缺陷**: Layer 6 使用 thinking 签名作为工具签名，风险太高

### 7.2 影响范围

- **Claude Code**: 工具调用丢失签名，导致 thinking 模式被禁用
- **多轮对话**: 签名无法在多轮对话中传递
- **用户体验**: 工具调用失败，影响功能完整性

### 7.3 修复优先级

1. **P0 Critical**: 删除重复函数，修复调用代码
2. **P1 High**: 修复工具签名缓存的时序问题
3. **P2 Medium**: 实现签名的独立缓存和持久化

### 7.4 预防措施

1. **代码审查**: 重构时确保删除旧代码
2. **单元测试**: 覆盖所有签名恢复路径
3. **集成测试**: 测试完整的请求-响应流程
4. **文档更新**: 记录签名缓存的架构和时序

---

**报告完成时间**: 2026-01-17
**下一步行动**: 实施 P0 修复方案
