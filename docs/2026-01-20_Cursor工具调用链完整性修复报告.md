# Cursor IDE 工具调用链完整性修复报告

**日期**: 2026-01-20
**问题**: Cursor IDE 在重试对话时发送不完整的工具调用链，导致 Claude 和 Gemini API 返回 400 错误
**修复状态**: ✅ 已修复

---

## 问题描述

用户在 Cursor IDE 中进行如下操作序列时触发错误：
1. 第一次对话：正常思考和回复
2. 第二次对话：模型决定调用工具，思考后输出工具调用，然后对话结束（可能被中断或截断）
3. 第三次对话：在同一位置重试（Retry）

此时会触发两个不同的 400 错误：

### 1. Claude API 错误
```
tool_use ids were found without tool_result blocks immediately after
```
**原因**：Cursor 发送了包含 `tool_use` 的历史消息，但没有附带对应的 `tool_result`。Claude API 严格要求每个 `tool_use` 必须紧跟一个 `tool_result`。

### 2. Gemini API 错误
```
GenerateContentRequest.contents[4].parts[0].function_response.name: Name cannot be empty.
```
**原因**：Cursor 发送了包含 `tool_result` 的历史消息，但对应的 `tool_use` 可能丢失或信息不全，导致无法解析出工具名称（`name`）。Gemini API 要求 `function_response` 必须包含非空的 `name` 字段。

---

## 根本原因分析

### 数据流追踪

1. **Cursor 客户端行为**：
   - 当用户点击 "Retry" 时，Cursor 会重新发送截止当前位置的历史消息
   - 如果之前的对话在工具调用阶段中断，发送的历史消息可能包含：
     - 只有 `tool_use` 没有 `tool_result`（孤儿 tool_use）
     - 只有 `tool_result` 没有 `tool_use`（孤儿 tool_result）
     - `tool_result` 消息中 `name` 字段为空或丢失

2. **服务器端处理缺陷**：
   - `src/converters/message_converter.py` 缺乏对孤儿 `tool_use` 的过滤逻辑
   - 虽然有对孤儿 `tool_result` 的过滤，但对 `name` 字段为空的情况处理不够健壮（依赖 `getattr(msg, "name", "unknown")` 但未处理 `None` 值）

---

## 修复方案

### 1. 修复 Claude API 400 错误 (Orphan tool_use)

在 `src/converters/message_converter.py` 中添加了双向验证逻辑：

1. **建立索引**：首先遍历所有消息，收集所有存在的 `tool_result` ID
   ```python
   tool_result_ids: set = set()
   for msg in messages:
       if msg.role == "tool":
           tool_result_ids.add(str(msg.tool_call_id))
   ```

2. **过滤孤儿 tool_use**：在处理 assistant 消息的 `tool_calls` 时，验证是否有对应的 result
   ```python
   if tc_id and str(tc_id) not in tool_result_ids:
       log.warning(f"Skipping orphan tool_use: {tc_id}...")
       continue
   ```

### 2. 修复 Gemini API 400 错误 (Empty tool name)

增强了 `tool_result` 的处理逻辑：

1. **建立映射**：收集 `tool_call_id` 到 `tool_name` 的映射
2. **增强名称恢复**：
   - 如果 `name` 为空/None，尝试从映射中恢复
   - 如果映射中也没有，使用 fallback 值 `tool_{id}` 或 `unknown_tool`
   ```python
   if not tool_name or not str(tool_name).strip():
       if str(tool_call_id) in tool_call_id_to_name:
           tool_name = tool_call_id_to_name[str(tool_call_id)]
       else:
           tool_name = f"tool_{tool_call_id}" if tool_call_id else "unknown_tool"
   ```

---

## 测试验证

编写了专门的测试脚本 `tests/reproduce_issue.py` (通过命令行运行验证)，覆盖以下场景：

1. **Orphan tool_use**：发送包含 `tool_calls` 但无 `tool` 消息的请求
   - 结果：`[OK] Orphan tool_use was correctly filtered`
   - 验证：Claude API 不再收到孤儿 tool_use，避免 400 错误

2. **Valid tool chain**：发送完整的 tool chain
   - 结果：`[OK] Valid tool_use was correctly preserved`
   - 验证：正常对话不受影响

3. **Empty tool name**：发送 `name=""` 的 tool 消息
   - 结果：`[OK] Tool name recovered from mapping`
   - 验证：Gemini API 收到有效的 name，避免 400 错误

4. **None tool name**：发送 `name=None` 的 tool 消息
   - 结果：`[OK] Tool name recovered from mapping`
   - 验证：Gemini API 收到有效的 name，避免 400 错误

---

## 结论

本次修复通过在 `message_converter.py` 中添加严格的**工具调用链完整性验证**，成功解决了 Cursor IDE 在重试场景下因发送不完整历史消息而导致的 API 错误。

- **Claude 兼容性**：确保所有 `tool_use` 都有对应的 `tool_result`
- **Gemini 兼容性**：确保所有 `function_response` 都有非空的 `name`

系统现在对客户端的异常行为具有更强的容错能力。

---

## 追加修复：签名字段名不一致问题

**时间**: 2026-01-20 19:45
**错误信息**: `messages.3.content.0: Invalid 'signature' in 'thinking' block`

### 问题描述

在工具调用场景中，当历史消息包含 thinking blocks 时，Claude API 返回 400 错误：
```
Invalid 'signature' in 'thinking' block
```

### 根本原因

系统中存在**签名字段名不一致**的问题：

1. **`normalize_content`** (unified_gateway_router.py:631-646) 使用 `signature` 字段名保存签名
2. **`has_valid_thoughtsignature`** (thoughtSignature_fix.py:124) 只检查 `thoughtSignature` 字段
3. **`sanitize_thinking_block`** (thoughtSignature_fix.py:160) 只保留 `thoughtSignature` 字段
4. **`_validate_thinking_block`** (sanitizer.py:260,266) 只读取 `thoughtSignature` 字段

导致的问题链：
1. 消息经过 `normalize_content` 后，thinking block 有 `signature` 字段
2. Sanitizer 检查 `thoughtSignature` 字段，发现没有
3. 尝试恢复签名失败
4. 降级为 text block，但原始 `signature` 字段仍存在
5. 最终发送到 Claude API 的消息包含无效的 `signature` 字段

### 修复方案

在三个关键位置添加对 `signature` 字段的兼容：

#### 1. `has_valid_thoughtsignature` (thoughtSignature_fix.py)
```python
# [FIX 2026-01-20] 兼容两种签名字段名：thoughtSignature 和 signature
thoughtsignature = block.get("thoughtSignature") or block.get("signature")
```

#### 2. `sanitize_thinking_block` (thoughtSignature_fix.py)
```python
# [FIX 2026-01-20] 兼容两种签名字段名：thoughtSignature 和 signature
thoughtsignature = block.get("thoughtSignature") or block.get("signature")
if thoughtsignature:
    sanitized["thoughtSignature"] = thoughtsignature
```

#### 3. `_validate_thinking_block` (sanitizer.py)
```python
# [FIX 2026-01-20] 兼容两种签名字段名：thoughtSignature 和 signature
signature = block.get("thoughtSignature") or block.get("signature")
client_signature = block.get("thoughtSignature") or block.get("signature")
```

### 测试验证

```
[TEST 1] thoughtSignature field - should be valid
[OK] has_valid_thoughtsignature with thoughtSignature: True

[TEST 2] signature field - should also be valid now
[OK] has_valid_thoughtsignature with signature: True

[TEST 3] sanitize_thinking_block with signature field
[OK] signature field correctly converted to thoughtSignature
[OK] extra_field correctly removed

[TEST 4] sanitize_thinking_block with thoughtSignature field
[OK] thoughtSignature field correctly preserved

[SUCCESS] All tests passed!
```

### 修复效果

- 无论客户端发送 `signature` 还是 `thoughtSignature` 字段，系统都能正确识别和处理
- 输出统一使用 `thoughtSignature` 字段名，符合 Claude API 规范
- 避免了因字段名不一致导致的签名验证失败和 400 错误

