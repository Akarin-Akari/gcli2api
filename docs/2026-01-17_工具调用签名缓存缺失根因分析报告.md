# 工具调用签名缓存缺失根因分析报告

**日期**: 2026-01-17
**分析者**: Claude Sonnet 4.5 (浮浮酱)
**问题**: 工具调用时出现 "No signature found for tool call" 警告

---

## 一、问题现象

### 1.1 用户报告

用户报告工具调用时仍然出现警告:
```
[02:29:53] [WARNING] [ANTHROPIC CONVERTER] No signature found for tool call: call_5a7036d6a8093d9d284eff6f, using placeholder
```

### 1.2 日志分析

通过分析 `log.jsonl` 文件,发现以下关键证据:

**证据 1: 大量 fallback 签名使用**
```json
{"timestamp": "2026-01-17T02:35:06.733708", "level": "WARNING", "message": "[SIGNATURE_RECOVERY] Using last signature as fallback for tool_id: call_0e4c89b269242496f4bd2945"}
{"timestamp": "2026-01-17T02:35:06.738718", "level": "WARNING", "message": "[SIGNATURE_RECOVERY] Using last signature as fallback for tool_id: call_b1bc6960df4a31e2042493d6"}
{"timestamp": "2026-01-17T02:35:06.744049", "level": "WARNING", "message": "[SIGNATURE_RECOVERY] Using last signature as fallback for tool_id: call_2e318f93bb68de493eb51ac8"}
```

**证据 2: 没有任何签名缓存成功的日志**
```bash
$ grep -i "cached tool signature" log.jsonl
# 结果: 空 (没有任何匹配)
```

**结论**: 工具ID签名根本没有被缓存,所有工具调用都在使用 fallback 签名。

---

## 二、签名缓存架构分析

### 2.1 签名缓存的完整生命周期

#### 阶段 1: 响应流式转换 (anthropic_streaming.py)

**位置**: `anthropic_streaming.py` 第 474-503 行

```python
if "functionCall" in part:
    # ... 省略其他代码 ...

    # [FIX 2026-01-16] 将 thoughtSignature 编码到工具ID中
    thoughtsignature = part.get("thoughtSignature")
    encoded_tool_id = encode_tool_id_with_signature(original_tool_id, thoughtsignature)

    if thoughtsignature:
        log.debug(f"[STREAMING] Encoded thoughtSignature into tool_id: {original_tool_id} -> {encoded_tool_id[:50]}...")

        # [FIX 2026-01-16] 缓存工具ID签名 (Layer 1)
        try:
            cache_tool_signature(original_tool_id, thoughtsignature)  # ← 这里应该缓存
        except Exception as e:
            log.warning(f"[SIGNATURE_CACHE] 工具ID签名缓存失败: {e}")
```

**预期行为**:
- 当下游返回 `functionCall` 时,提取 `thoughtSignature`
- 调用 `cache_tool_signature(original_tool_id, thoughtsignature)` 缓存签名
- 记录 DEBUG 日志: `"[STREAMING] Encoded thoughtSignature into tool_id: ..."`

#### 阶段 2: 请求转换 (anthropic_converter.py)

**位置**: `anthropic_converter.py` 第 727-741 行

```python
elif item_type == "tool_use":
    # [FIX 2026-01-16] 从编码的工具ID中解码签名
    encoded_id = item.get("id") or ""
    original_id, thoughtsignature = decode_tool_id_and_signature(encoded_id)

    # [FIX 2026-01-17] 缓存工具ID签名 (Layer 1)
    if thoughtsignature and len(thoughtsignature) >= MIN_SIGNATURE_LENGTH:
        from src.signature_cache import cache_tool_signature
        try:
            cache_tool_signature(original_id, thoughtsignature)  # ← 这里也应该缓存
            log.debug(f"[ANTHROPIC CONVERTER] Cached tool signature for id: {original_id}")
        except Exception as e:
            log.warning(f"[SIGNATURE_CACHE] 工具ID签名缓存失败: {e}")
```

**预期行为**:
- 从客户端请求中提取 `tool_use` 块
- 解码工具ID,提取签名
- 调用 `cache_tool_signature(original_id, thoughtsignature)` 缓存签名
- 记录 DEBUG 日志: `"[ANTHROPIC CONVERTER] Cached tool signature for id: ..."`

#### 阶段 3: 签名恢复 (anthropic_converter.py)

**位置**: `anthropic_converter.py` 第 424-484 行

```python
def recover_signature_for_tool_use(
    tool_id: str,
    encoded_tool_id: str,
    signature: Optional[str],
    last_thought_signature: Optional[str],
    session_id: Optional[str] = None
) -> Optional[str]:
    """多层签名恢复策略"""

    # 优先级 1: 客户端提供的签名
    if signature and len(signature) >= MIN_SIGNATURE_LENGTH:
        return signature

    # 优先级 2: 上下文中的签名
    if last_thought_signature and len(last_thought_signature) >= MIN_SIGNATURE_LENGTH:
        return last_thought_signature

    # 优先级 3: 从编码的工具ID中解码
    _, decoded_sig = decode_tool_id_and_signature(encoded_tool_id)
    if decoded_sig and len(decoded_sig) >= MIN_SIGNATURE_LENGTH:
        log.debug(f"[SIGNATURE_RECOVERY] Recovered from encoded tool_id: {tool_id}")
        return decoded_sig

    # 优先级 5: 工具ID缓存
    tool_sig = get_tool_signature(tool_id)  # ← 这里应该从缓存读取
    if tool_sig:
        log.debug(f"[SIGNATURE_RECOVERY] Recovered from tool_id cache: {tool_id}")
        return tool_sig

    # 优先级 6: 最近签名（fallback）
    last_sig = get_last_signature()
    if last_sig:
        log.warning(f"[SIGNATURE_RECOVERY] Using last signature as fallback for tool_id: {tool_id}")
        return last_sig

    return None
```

**预期行为**:
- 按优先级尝试多种签名恢复策略
- 如果工具ID缓存命中,记录 DEBUG 日志: `"[SIGNATURE_RECOVERY] Recovered from tool_id cache: ..."`
- 如果所有策略失败,使用 fallback 签名,记录 WARNING 日志: `"[SIGNATURE_RECOVERY] Using last signature as fallback..."`

### 2.2 签名缓存实现 (signature_cache.py)

**工具ID签名缓存**:

```python
class SignatureCache:
    def __init__(self, ...):
        # [FIX 2026-01-16] 新增：工具ID签名缓存 (Layer 1)
        self._tool_signatures: Dict[str, CacheEntry] = {}
        self._tool_lock = threading.Lock()

    def cache_tool_signature(self, tool_id: str, signature: str) -> bool:
        """缓存工具ID到签名的映射"""
        if not tool_id or not signature:
            return False

        if not self._is_valid_signature(signature):
            return False

        with self._tool_lock:
            self._tool_signatures[tool_id] = CacheEntry(
                signature=signature,
                thinking_text="",
                thinking_text_preview="",
                timestamp=time.time()
            )
            log.debug(f"[SIGNATURE_CACHE] 工具ID签名缓存成功: tool_id={tool_id}, sig={signature[:20]}...")
        return True

    def get_tool_signature(self, tool_id: str) -> Optional[str]:
        """通过工具ID获取签名"""
        if not tool_id:
            return None

        with self._tool_lock:
            entry = self._tool_signatures.get(tool_id)
            if entry:
                if not entry.is_expired(self._ttl_seconds):
                    log.debug(f"[SIGNATURE_CACHE] 工具ID签名缓存命中: tool_id={tool_id}")
                    return entry.signature
                else:
                    del self._tool_signatures[tool_id]
                    log.debug(f"[SIGNATURE_CACHE] 工具ID签名缓存过期: tool_id={tool_id}")
        return None
```

**便捷函数**:

```python
def cache_tool_signature(tool_id: str, signature: str) -> bool:
    """缓存工具ID到签名的映射（便捷函数）"""
    # [FIX 2026-01-12] 迁移模式支持
    if _is_migration_mode():
        # 注意：CacheFacade 可能还没实现 cache_tool_signature
        pass

    return get_signature_cache().cache_tool_signature(tool_id, signature)

def get_tool_signature(tool_id: str) -> Optional[str]:
    """通过工具ID获取签名（便捷函数）"""
    # [FIX 2026-01-12] 迁移模式支持
    if _is_migration_mode():
        # 注意：CacheFacade 可能还没实现 get_tool_signature
        pass

    return get_signature_cache().get_tool_signature(tool_id)
```

---

## 三、根因分析

### 3.1 核心问题

**问题**: 迁移模式下的便捷函数代理缺陷

在 `signature_cache.py` 第 684-719 行:

```python
def cache_tool_signature(tool_id: str, signature: str) -> bool:
    """缓存工具ID到签名的映射（便捷函数）"""
    # [FIX 2026-01-12] 迁移模式支持
    if _is_migration_mode():
        # 注意：CacheFacade 可能还没实现 cache_tool_signature，这里暂时只支持本地缓存
        # 如果需要支持迁移模式，需要在 CacheFacade 中添加相应方法
        pass  # ← 问题所在：直接 pass，没有调用本地缓存！

    return get_signature_cache().cache_tool_signature(tool_id, signature)

def get_tool_signature(tool_id: str) -> Optional[str]:
    """通过工具ID获取签名（便捷函数）"""
    # [FIX 2026-01-12] 迁移模式支持
    if _is_migration_mode():
        # 注意：CacheFacade 可能还没实现 get_tool_signature，这里暂时只支持本地缓存
        pass  # ← 问题所在：直接 pass，没有调用本地缓存！

    return get_signature_cache().get_tool_signature(tool_id)
```

**根本原因**:

1. **迁移模式默认启用**: 在 `signature_cache.py` 第 743-773 行,`_is_migration_mode()` 默认返回 `True`
   ```python
   def _is_migration_mode() -> bool:
       # [FIX 2026-01-12] 默认启用迁移模式，以确保 DUAL_WRITE 架构生效
       if env_value in ("false", "0", "no", "off"):
           result = False
       else:
           # 默认启用迁移模式
           result = True
   ```

2. **便捷函数代理不完整**: 当迁移模式启用时,`cache_tool_signature()` 和 `get_tool_signature()` 直接 `pass`,既没有调用 `CacheFacade`,也没有调用本地缓存

3. **执行流程**:
   ```
   anthropic_streaming.py:
     cache_tool_signature(tool_id, sig)
       ↓
   signature_cache.py (便捷函数):
     if _is_migration_mode():  # True
         pass  # ← 直接返回，什么都不做！
     return get_signature_cache().cache_tool_signature(...)  # ← 永远不会执行
   ```

4. **结果**:
   - 签名永远不会被缓存
   - `get_tool_signature()` 永远返回 `None`
   - 所有工具调用都回退到 fallback 签名

### 3.2 为什么其他缓存函数正常工作?

对比其他便捷函数 (如 `cache_signature()`, `get_cached_signature()`):

```python
def cache_signature(thinking_text: str, signature: str, model: Optional[str] = None) -> bool:
    """缓存 signature（便捷函数）"""
    # [FIX 2026-01-12] 迁移模式支持
    if _is_migration_mode():
        facade = _get_migration_facade()
        if facade:
            log.debug("[SIGNATURE_CACHE] cache_signature: 代理到迁移门面")
            return facade.cache_signature(thinking_text, signature, model)  # ← 调用 facade

    return get_signature_cache().set(thinking_text, signature, model)  # ← fallback 到本地缓存
```

**区别**:
- `cache_signature()` 等函数: 如果 `facade` 存在,调用 `facade.cache_signature()`;否则 fallback 到本地缓存
- `cache_tool_signature()`: 直接 `pass`,既不调用 facade,也不调用本地缓存

### 3.3 为什么没有报错?

因为 `cache_tool_signature()` 和 `get_tool_signature()` 都有返回值:
- `cache_tool_signature()` 在 `pass` 后隐式返回 `None`,Python 会将其视为 `False`
- `get_tool_signature()` 在 `pass` 后隐式返回 `None`

调用方没有检查返回值是否为 `False`,所以没有触发异常,但签名缓存完全失效。

---

## 四、影响范围

### 4.1 受影响的功能

1. **工具调用签名缓存**: 完全失效
2. **签名恢复策略**: 优先级 5 (工具ID缓存) 永远失败
3. **所有工具调用**: 都使用 fallback 签名 (优先级 6)

### 4.2 不受影响的功能

1. **思维块签名缓存**: 正常工作 (使用 `cache_signature()` 和 `get_cached_signature()`)
2. **签名编码/解码**: 正常工作 (优先级 3)
3. **最近签名 fallback**: 正常工作 (优先级 6)

### 4.3 为什么系统仍然能运行?

因为签名恢复策略有 6 个优先级,即使优先级 5 (工具ID缓存) 失效,仍然可以回退到:
- **优先级 3**: 从编码的工具ID中解码签名
- **优先级 6**: 使用最近缓存的签名 (fallback)

所以系统仍然能够工作,但会出现大量 WARNING 日志。

---

## 五、修复方案

### 5.1 方案 A: 修复便捷函数代理 (推荐)

**修改位置**: `signature_cache.py` 第 684-719 行

```python
def cache_tool_signature(tool_id: str, signature: str) -> bool:
    """缓存工具ID到签名的映射（便捷函数）"""
    # [FIX 2026-01-17] 修复迁移模式代理缺陷
    if _is_migration_mode():
        facade = _get_migration_facade()
        if facade and hasattr(facade, 'cache_tool_signature'):
            log.debug("[SIGNATURE_CACHE] cache_tool_signature: 代理到迁移门面")
            return facade.cache_tool_signature(tool_id, signature)
        # 如果 facade 不存在或不支持此方法，fallback 到本地缓存
        log.debug("[SIGNATURE_CACHE] cache_tool_signature: 迁移门面不可用，使用本地缓存")

    return get_signature_cache().cache_tool_signature(tool_id, signature)

def get_tool_signature(tool_id: str) -> Optional[str]:
    """通过工具ID获取签名（便捷函数）"""
    # [FIX 2026-01-17] 修复迁移模式代理缺陷
    if _is_migration_mode():
        facade = _get_migration_facade()
        if facade and hasattr(facade, 'get_tool_signature'):
            log.debug("[SIGNATURE_CACHE] get_tool_signature: 代理到迁移门面")
            return facade.get_tool_signature(tool_id)
        # 如果 facade 不存在或不支持此方法，fallback 到本地缓存
        log.debug("[SIGNATURE_CACHE] get_tool_signature: 迁移门面不可用，使用本地缓存")

    return get_signature_cache().get_tool_signature(tool_id)
```

**优点**:
- 保持架构一致性
- 支持未来的 CacheFacade 集成
- 优雅降级到本地缓存

**缺点**:
- 需要修改两个函数

### 5.2 方案 B: 禁用迁移模式 (临时方案)

**修改位置**: 环境变量或配置文件

```bash
# 设置环境变量
export CACHE_USE_MIGRATION_ADAPTER=false
```

或修改 `signature_cache.py` 第 743-773 行:

```python
def _is_migration_mode() -> bool:
    # [FIX 2026-01-17] 临时禁用迁移模式，直到 CacheFacade 完全实现
    return False
```

**优点**:
- 快速修复
- 无需修改代码逻辑

**缺点**:
- 破坏了 DUAL_WRITE 架构
- 不是长期解决方案

### 5.3 推荐方案

**采用方案 A**,原因:
1. 保持架构完整性
2. 支持渐进式迁移
3. 优雅降级,不会破坏现有功能
4. 为未来的 CacheFacade 集成预留空间

---

## 六、验证计划

### 6.1 修复后的预期日志

**响应阶段** (anthropic_streaming.py):
```
[DEBUG] [STREAMING] Encoded thoughtSignature into tool_id: call_xxx -> call_xxx__thought__...
[DEBUG] [SIGNATURE_CACHE] cache_tool_signature: 迁移门面不可用，使用本地缓存
[DEBUG] [SIGNATURE_CACHE] 工具ID签名缓存成功: tool_id=call_xxx, sig=EqQBCg...
```

**请求阶段** (anthropic_converter.py):
```
[DEBUG] [ANTHROPIC CONVERTER] Cached tool signature for id: call_xxx
[DEBUG] [SIGNATURE_CACHE] cache_tool_signature: 迁移门面不可用，使用本地缓存
[DEBUG] [SIGNATURE_CACHE] 工具ID签名缓存成功: tool_id=call_xxx, sig=EqQBCg...
```

**签名恢复阶段**:
```
[DEBUG] [SIGNATURE_CACHE] get_tool_signature: 迁移门面不可用，使用本地缓存
[DEBUG] [SIGNATURE_CACHE] 工具ID签名缓存命中: tool_id=call_xxx
[DEBUG] [SIGNATURE_RECOVERY] Recovered from tool_id cache: call_xxx
```

### 6.2 验证步骤

1. **启用 DEBUG 日志**:
   ```bash
   export ANTHROPIC_DEBUG=1
   ```

2. **运行测试**:
   - 发送包含工具调用的请求
   - 观察日志输出

3. **检查点**:
   - [ ] 响应阶段出现 `"工具ID签名缓存成功"`
   - [ ] 请求阶段出现 `"Cached tool signature for id"`
   - [ ] 签名恢复阶段出现 `"Recovered from tool_id cache"`
   - [ ] 不再出现 `"Using last signature as fallback"`

4. **性能验证**:
   - 检查缓存命中率
   - 确认 fallback 使用次数显著减少

---

## 七、总结

### 7.1 问题根源

工具调用签名缓存失效的根本原因是:
1. **迁移模式默认启用**
2. **便捷函数代理不完整**: `cache_tool_signature()` 和 `get_tool_signature()` 在迁移模式下直接 `pass`,既不调用 facade,也不调用本地缓存
3. **缺少 fallback 逻辑**: 其他便捷函数 (如 `cache_signature()`) 在 facade 不可用时会 fallback 到本地缓存,但工具ID缓存函数没有这个逻辑

### 7.2 关键发现

1. **签名从未被缓存**: 日志中没有任何 `"Cached tool signature"` 记录
2. **所有工具调用都使用 fallback**: 日志中大量 `"Using last signature as fallback"` 警告
3. **系统仍然能运行**: 因为签名恢复策略有多个优先级,即使工具ID缓存失效,仍然可以回退到其他策略

### 7.3 修复建议

采用**方案 A** (修复便捷函数代理),因为:
- 保持架构完整性
- 支持渐进式迁移
- 优雅降级,不会破坏现有功能
- 为未来的 CacheFacade 集成预留空间

### 7.4 经验教训

1. **迁移模式需要完整实现**: 不能只实现部分函数的代理,必须确保所有函数都有 fallback 逻辑
2. **日志是最好的调试工具**: 通过分析日志,快速定位了问题根源
3. **代码注释很重要**: `# 注意：CacheFacade 可能还没实现 cache_tool_signature` 这个注释明确指出了问题所在

---

**报告完成时间**: 2026-01-17 02:40
**下一步行动**: 实施修复方案 A,并进行验证测试
