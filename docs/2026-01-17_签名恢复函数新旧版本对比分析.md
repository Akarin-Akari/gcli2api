# 签名恢复函数新旧版本对比分析

**分析时间**: 2026-01-17 22:30  
**分析人员**: 浮浮酱 (Claude Opus 4.5)

---

## 一、函数位置

### 1.1 新版本（实际实现）

**文件**: `gcli2api/src/converters/signature_recovery.py`  
**行数**: 183-278  
**函数签名**:
```python
def recover_signature_for_tool_use(
    tool_id: str,
    encoded_tool_id: str,
    client_signature: Optional[str] = None,
    context_signature: Optional[str] = None,
    session_id: Optional[str] = None,
    use_placeholder_fallback: bool = True
) -> RecoveryResult:
```

### 1.2 旧版本（兼容包装）

**文件**: `gcli2api/src/anthropic_converter.py`  
**行数**: 424-461  
**函数签名**:
```python
def recover_signature_for_tool_use(
    tool_id: str,
    encoded_tool_id: str,
    signature: Optional[str],
    last_thought_signature: Optional[str],
    session_id: Optional[str] = None
) -> Optional[str]:
```

**作用**: 这是一个兼容包装函数，内部调用新版本，然后提取 `result.signature` 返回。

---

## 二、架构对比

### 2.1 返回值类型

| 版本 | 返回值类型 | 说明 |
|------|-----------|------|
| **旧版本** | `Optional[str]` | 直接返回签名字符串或 `None` |
| **新版本** | `RecoveryResult` | 返回结构化结果，包含签名、来源、thinking 文本等 |

**新版本的 RecoveryResult 结构**:
```python
@dataclass
class RecoveryResult:
    signature: Optional[str]           # 恢复的签名
    source: RecoverySource              # 恢复来源（枚举）
    thinking_text: Optional[str] = None # 配对的 thinking 文本（如果有）
    
    @property
    def success(self) -> bool:         # 是否成功恢复
    @property
    def is_placeholder(self) -> bool:  # 是否使用占位符
```

### 2.2 参数命名

| 参数位置 | 旧版本 | 新版本 | 说明 |
|---------|--------|--------|------|
| 第 3 个 | `signature` | `client_signature` | 更明确的命名 |
| 第 4 个 | `last_thought_signature` | `context_signature` | 更通用的命名 |
| 第 6 个 | ❌ 无 | `use_placeholder_fallback` | **新增参数** |

### 2.3 验证逻辑

**旧版本**:
```python
if signature and len(signature) >= MIN_SIGNATURE_LENGTH:
    return signature
```

**新版本**:
```python
def is_valid_signature(signature: Optional[str]) -> bool:
    """统一的签名验证函数"""
    if not signature or not isinstance(signature, str):
        return False
    if len(signature) < MIN_SIGNATURE_LENGTH:
        return False
    if signature == SKIP_SIGNATURE_VALIDATOR:
        return False  # 占位符不算有效签名
    return True

# 使用
if is_valid_signature(client_signature):
    return RecoveryResult(...)
```

**优势**:
- ✅ 统一的验证逻辑，避免重复代码
- ✅ 明确排除占位符签名
- ✅ 类型检查更严格

---

## 三、逻辑对比（6层恢复策略）

### 3.1 Layer 1: Client Signature

**旧版本**:
```python
if signature and len(signature) >= MIN_SIGNATURE_LENGTH:
    log.debug(f"[SIGNATURE_RECOVERY] Layer 1: Client signature for tool_id={tool_id}")
    return signature
```

**新版本**:
```python
if is_valid_signature(client_signature):
    log.debug(f"[SIGNATURE_RECOVERY] Tool Layer 1: Client signature found for tool_id={tool_id}")
    return RecoveryResult(
        signature=client_signature,
        source=RecoverySource.CLIENT
    )
```

**差异**: 
- ✅ 使用统一的验证函数
- ✅ 返回结构化结果，包含来源信息
- ✅ 日志更详细（"found" vs 直接返回）

### 3.2 Layer 2: Context Signature

**旧版本**:
```python
if last_thought_signature and len(last_thought_signature) >= MIN_SIGNATURE_LENGTH:
    log.debug(f"[SIGNATURE_RECOVERY] Layer 2: Context signature for tool_id={tool_id}")
    return last_thought_signature
```

**新版本**:
```python
if is_valid_signature(context_signature):
    log.debug(f"[SIGNATURE_RECOVERY] Tool Layer 2: Context signature found for tool_id={tool_id}")
    return RecoveryResult(
        signature=context_signature,
        source=RecoverySource.CONTEXT
    )
```

**差异**: 同 Layer 1

### 3.3 Layer 3: Encoded Tool ID

**旧版本**:
```python
_, decoded_sig = decode_tool_id_and_signature(encoded_tool_id)
if decoded_sig and len(decoded_sig) >= MIN_SIGNATURE_LENGTH:
    log.debug(f"[SIGNATURE_RECOVERY] Layer 3: Decoded from encoded tool_id={tool_id}")
    return decoded_sig
```

**新版本**:
```python
_, decoded_sig = decode_tool_id_and_signature(encoded_tool_id)
if is_valid_signature(decoded_sig):
    log.debug(f"[SIGNATURE_RECOVERY] Tool Layer 3: Decoded from encoded tool_id={tool_id}")
    return RecoveryResult(
        signature=decoded_sig,
        source=RecoverySource.ENCODED_TOOL_ID
    )
```

**差异**: 同 Layer 1

### 3.4 Layer 4: Session Cache

**旧版本**:
```python
if session_id:
    session_sig = get_session_signature(session_id)
    if session_sig and len(session_sig) >= MIN_SIGNATURE_LENGTH:
        log.debug(f"[SIGNATURE_RECOVERY] Layer 4: Session cache hit for tool_id={tool_id}")
        return session_sig
```

**新版本**:
```python
if session_id:
    session_sig = get_session_signature(session_id)
    if is_valid_signature(session_sig):
        log.debug(f"[SIGNATURE_RECOVERY] Tool Layer 4: Session cache hit for tool_id={tool_id}")
        return RecoveryResult(
            signature=session_sig,
            source=RecoverySource.SESSION_CACHE
        )
```

**差异**: 同 Layer 1

### 3.5 Layer 5: Tool Cache

**旧版本**:
```python
tool_sig = get_tool_signature(tool_id)
if tool_sig and len(tool_sig) >= MIN_SIGNATURE_LENGTH:
    log.debug(f"[SIGNATURE_RECOVERY] Layer 5: Tool cache hit for tool_id={tool_id}")
    return tool_sig
```

**新版本**:
```python
tool_sig = get_tool_signature(tool_id)
if is_valid_signature(tool_sig):
    log.debug(f"[SIGNATURE_RECOVERY] Tool Layer 5: Tool cache hit for tool_id={tool_id}")
    return RecoveryResult(
        signature=tool_sig,
        source=RecoverySource.TOOL_CACHE
    )
```

**差异**: 同 Layer 1

### 3.6 Layer 6: Last Signature

**旧版本**:
```python
last_sig = get_last_signature()
if last_sig and len(last_sig) >= MIN_SIGNATURE_LENGTH:
    log.info(f"[SIGNATURE_RECOVERY] Layer 6: Using last signature as fallback for tool_id={tool_id}")
    return last_sig
```

**新版本**:
```python
last_sig = get_last_signature()
if is_valid_signature(last_sig):
    log.info(f"[SIGNATURE_RECOVERY] Tool Layer 6: Using last cached signature for tool_id={tool_id}")
    return RecoveryResult(
        signature=last_sig,
        source=RecoverySource.LAST_SIGNATURE
    )
```

**差异**: 同 Layer 1

### 3.7 Fallback 处理

**旧版本**:
```python
log.warning(f"[SIGNATURE_RECOVERY] All 6 layers failed for tool_id={tool_id}")
return None  # ❌ 直接返回 None，调用方需要自己处理占位符
```

**新版本**:
```python
# 所有策略都失败
if use_placeholder_fallback:
    log.warning(f"[SIGNATURE_RECOVERY] All strategies failed for tool_id={tool_id}, using placeholder")
    return RecoveryResult(
        signature=SKIP_SIGNATURE_VALIDATOR,
        source=RecoverySource.PLACEHOLDER
    )

log.warning(f"[SIGNATURE_RECOVERY] All strategies failed for tool_id={tool_id}, no signature available")
return RecoveryResult(
    signature=None,
    source=RecoverySource.NONE
)
```

**差异**:
- ✅ **新增占位符 fallback 选项**：可以通过 `use_placeholder_fallback` 参数控制
- ✅ **明确的失败状态**：返回 `RecoveryResult(source=NONE)` 而不是 `None`
- ✅ **更好的可观测性**：调用方可以通过 `result.is_placeholder` 判断是否使用了占位符

---

## 四、功能增强

### 4.1 新增功能

1. **结构化返回值** (`RecoveryResult`):
   - 提供恢复来源信息 (`source`)
   - 提供配对 thinking 文本 (`thinking_text`)
   - 提供便捷属性 (`success`, `is_placeholder`)

2. **占位符 fallback 控制**:
   - `use_placeholder_fallback` 参数允许调用方控制是否使用占位符
   - 旧版本必须由调用方自己处理占位符逻辑

3. **统一的验证逻辑**:
   - `is_valid_signature()` 函数统一处理所有验证
   - 明确排除占位符签名

4. **更好的日志**:
   - 所有日志都包含 "Tool Layer X" 前缀，便于过滤
   - 使用 "found" 而不是直接返回，更清晰

### 4.2 没有删减

**✅ 所有 6 层恢复策略都完整保留**：
- Layer 1: Client signature ✅
- Layer 2: Context signature ✅
- Layer 3: Encoded Tool ID ✅
- Layer 4: Session Cache ✅
- Layer 5: Tool Cache ✅
- Layer 6: Last Signature ✅

**✅ 所有逻辑都保持一致**，只是：
- 验证方式更统一（`is_valid_signature`）
- 返回值更结构化（`RecoveryResult`）
- 增加了占位符 fallback 选项

---

## 五、使用示例

### 5.1 旧版本使用方式

```python
final_sig = recover_signature_for_tool_use(
    tool_id=original_id,
    encoded_tool_id=encoded_id,
    signature=thoughtsignature,
    last_thought_signature=context_signature,
    session_id=session_id
)

if final_sig:
    fc_part["thoughtSignature"] = final_sig
else:
    # 调用方需要自己处理占位符
    fc_part["thoughtSignature"] = SKIP_SIGNATURE_VALIDATOR
```

### 5.2 新版本使用方式（直接调用）

```python
from src.converters.signature_recovery import recover_signature_for_tool_use

result = recover_signature_for_tool_use(
    tool_id=original_id,
    encoded_tool_id=encoded_id,
    client_signature=thoughtsignature,
    context_signature=context_signature,
    session_id=session_id,
    use_placeholder_fallback=True
)

if result.success:
    fc_part["thoughtSignature"] = result.signature
    log.info(f"Recovered from {result.source.value}")  # 可以知道恢复来源
elif result.is_placeholder:
    fc_part["thoughtSignature"] = result.signature  # 已经是占位符
else:
    # 真正失败
    log.error("Signature recovery failed")
```

### 5.3 兼容包装使用方式（当前）

```python
# 通过兼容包装调用，接口与旧版本一致
final_sig = recover_signature_for_tool_use(
    tool_id=original_id,
    encoded_tool_id=encoded_id,
    signature=thoughtsignature,
    last_thought_signature=context_signature,
    session_id=session_id
)

# 行为与旧版本完全一致
if final_sig:
    fc_part["thoughtSignature"] = final_sig
else:
    fc_part["thoughtSignature"] = SKIP_SIGNATURE_VALIDATOR
```

---

## 六、总结

### 6.1 架构改进

| 方面 | 旧版本 | 新版本 | 改进 |
|------|--------|--------|------|
| **返回值** | `Optional[str]` | `RecoveryResult` | ✅ 结构化，提供更多信息 |
| **验证逻辑** | 分散在各层 | `is_valid_signature()` | ✅ 统一验证 |
| **占位符处理** | 调用方处理 | 内置 fallback 选项 | ✅ 更灵活 |
| **可观测性** | 仅日志 | 结构化结果 + 日志 | ✅ 更好的调试体验 |

### 6.2 逻辑完整性

**✅ 没有删减任何逻辑**：
- 所有 6 层恢复策略都完整保留
- 所有验证逻辑都保持一致
- 只是实现方式更优雅、更结构化

### 6.3 向后兼容

**✅ 完全向后兼容**：
- 兼容包装函数保持旧版本接口
- 调用方无需修改代码
- 可以逐步迁移到新版本接口

---

**结论**: 新版本是**增强而非删减**，所有逻辑都完整保留，只是实现更优雅、功能更强大。
