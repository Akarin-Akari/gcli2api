# SCID 状态机与内容 Hash 组合方案 - 开发指导文档

**文档创建时间**: 2026-01-17
**作者**: Claude Opus 4.5 (浮浮酱)
**基于**: Codex GPT-5.2 的 SCID 状态机方案 + 浮浮酱的内容 Hash 方案
**目标读者**: 后续开发 Agent
**项目**: gcli2api

---

## 一、执行摘要

### 1.1 本方案解决什么问题

**核心问题**：Cursor/Augment 等 IDE 在回放历史消息时会对 thinking 文本进行变形（trim、换行转换、截断、重排等），导致 Anthropic API 返回 `Invalid signature in thinking block` 错误。

**关键洞察**：
- Anthropic 的 `signature` 与 **thinking 文本的字节序列强绑定**
- 任何文本变化都会导致签名验证失败
- 网关**无法生成**新的合法签名，只能复用历史配对的 `(thinking_text, signature)`

### 1.2 方案定位

| 客户端类型 | 是否启用本方案 | 原因 |
|-----------|---------------|------|
| **Cursor** | ✅ 启用 | IDE 会变形 thinking 文本 |
| **Augment** | ✅ 启用 | IDE 会变形 thinking 文本 |
| **Claude Code** | ❌ 不启用 | 原生客户端，回放可信 |
| **其他 OpenAI 兼容客户端** | ⚠️ 可选 | 视具体行为决定 |

### 1.3 核心策略

```
网关成为"权威状态机"：
- 可验证 → 使用服务端权威历史，保留 extended thinking
- 不可验证 → 降级为 text 或删除 thinking，禁用 thinkingConfig
```

---

## 二、问题本质分析

### 2.1 Anthropic Signature 的绑定机制

```
signature = f(thinking_text_bytes)

任何变化都会导致验证失败：
- "Hello\n" vs "Hello\r\n"     → 失败
- "Hello " vs "Hello"          → 失败（trailing space）
- "Hello\nWorld" vs "HelloWorld" → 失败
```

### 2.2 IDE 的破坏行为清单

| 破坏类型 | 具体行为 | 影响 |
|---------|---------|------|
| **字段丢弃** | 丢弃 `signature`、`thoughtSignature`、`cache_control` | 签名丢失 |
| **文本归一化** | `\r\n` ↔ `\n`、trim、Unicode 归一化 | 签名失效 |
| **内容截断** | 为 UI/性能截断长文本 | 签名失效 |
| **结构重排** | 合并 content blocks、调整顺序 | 签名失效 |
| **tool_id 变化** | `toolu_xxx` → `call_xxx` | 缓存 miss |

### 2.3 现有方案的局限

**现有 6 层签名恢复策略**：
1. Client 提供的签名
2. 上下文中的签名
3. 编码的 tool_id 解码
4. Session Cache
5. Tool Cache
6. Last Signature (fallback)

**局限**：所有层都假设 thinking 文本未被变形。即使找到了正确的 signature，如果 thinking 文本已变形，仍然会 400。

---

## 三、组合方案架构

### 3.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         gcli2api 网关                                    │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌──────────────┐    ┌──────────────────┐    ┌──────────────────┐       │
│  │ IDE 请求入口 │───→│ 客户端类型检测器 │───→│ 路由分发         │       │
│  └──────────────┘    └──────────────────┘    └────────┬─────────┘       │
│                                                        │                 │
│                    ┌───────────────────────────────────┼────────────┐   │
│                    │                                   │            │   │
│                    ▼                                   ▼            │   │
│  ┌─────────────────────────────┐    ┌─────────────────────────────┐│   │
│  │   IDE 兼容层 (新增)         │    │   原生客户端路径            ││   │
│  │   - SCID 状态机             │    │   - 现有流程不变            ││   │
│  │   - 权威历史管理            │    │   - 6层签名恢复             ││   │
│  │   - 统一 Sanitizer          │    │   - SQLite 持久化           ││   │
│  │   - 内容 Hash 辅助          │    └─────────────────────────────┘│   │
│  └──────────────┬──────────────┘                                    │   │
│                 │                                                    │   │
│                 ▼                                                    │   │
│  ┌─────────────────────────────────────────────────────────────────┐│   │
│  │                    SQLite 持久化层                               ││   │
│  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ ││   │
│  │  │ signature_cache │  │ conversation_   │  │ content_hash_   │ ││   │
│  │  │ (现有)          │  │ state (新增)    │  │ cache (新增)    │ ││   │
│  │  └─────────────────┘  └─────────────────┘  └─────────────────┘ ││   │
│  └─────────────────────────────────────────────────────────────────┘│   │
│                                                                      │   │
└──────────────────────────────────────────────────────────────────────────┘
```

### 3.2 核心组件

| 组件 | 职责 | 新增/复用 |
|------|------|----------|
| **ClientTypeDetector** | 检测请求来源（IDE/CLI） | 新增 |
| **ConversationStateManager** | SCID 生成、状态存储与加载 | 新增 |
| **AnthropicSanitizer** | 最终发送前的 payload 校验与修复 | 新增 |
| **ContentHashCache** | 基于工具内容的签名缓存 | 新增 |
| **SignatureDatabase** | SQLite 持久化存储 | 复用扩展 |

---

## 四、客户端类型检测

### 4.1 检测策略

```
检测优先级：
1. User-Agent 头部特征
2. 请求路径特征
3. 请求体结构特征
4. 配置白名单/黑名单
```

### 4.2 检测规则

| 客户端 | 检测特征 | 分类 |
|--------|---------|------|
| **Cursor** | UA 包含 "Cursor"、路径 `/antigravity/` | IDE |
| **Augment** | 路径 `/gateway/`、NDJSON 格式 | IDE |
| **Claude Code** | UA 包含 "claude-code"、标准 Anthropic 格式 | CLI |
| **其他** | 默认 | 可配置 |

### 4.3 配置项

```python
# 环境变量或配置文件
IDE_COMPAT_ENABLED = True                    # 总开关
IDE_COMPAT_USER_AGENTS = ["Cursor", "Augment", "VSCode"]  # UA 匹配列表
IDE_COMPAT_PATHS = ["/antigravity/", "/gateway/"]         # 路径匹配列表
CLI_TRUSTED_USER_AGENTS = ["claude-code", "anthropic-cli"] # 可信客户端
```

---

## 五、SCID 状态机

### 5.1 SCID 定义

**Server Conversation ID (SCID)**：网关生成的会话唯一标识符，用于关联服务端权威状态。

```
格式建议：scid_{timestamp}_{random_hex}
示例：scid_1737100800_a1b2c3d4e5f6
```

### 5.2 SCID 传递协议

**请求时**：
```http
POST /antigravity/v1/messages
X-AG-Conversation-Id: scid_1737100800_a1b2c3d4e5f6
```

**响应时**：
```http
HTTP/1.1 200 OK
X-AG-Conversation-Id: scid_1737100800_a1b2c3d4e5f6

# 或在响应体中（SSE 场景）
event: message_start
data: {"type": "message_start", "_gateway": {"conversation_id": "scid_..."}}
```

### 5.3 状态数据模型

```
ConversationState:
  - scid: str                              # 会话 ID
  - history: List[AuthoritativeMessage]    # 权威历史消息
  - last_valid_thinking: (signature, text) # 最后有效的 thinking 配对
  - tool_map: Dict[tool_id, ToolRecord]    # 工具调用映射
  - created_at: datetime
  - updated_at: datetime
  - expires_at: datetime                   # TTL
```

### 5.4 状态存储

**复用现有 SQLite 架构**：

```sql
CREATE TABLE IF NOT EXISTS conversation_state (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    scid TEXT UNIQUE NOT NULL,
    history_json TEXT NOT NULL,           -- 权威历史 (JSON 序列化)
    last_thinking_text TEXT,
    last_signature TEXT,
    tool_map_json TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    expires_at TEXT,
    access_count INTEGER DEFAULT 0
);

CREATE INDEX IF NOT EXISTS idx_conversation_scid ON conversation_state(scid);
CREATE INDEX IF NOT EXISTS idx_conversation_expires ON conversation_state(expires_at);
```

---

## 六、请求处理流程

### 6.1 IDE 请求处理（有 SCID）

```
1. 接收请求，提取 SCID
2. 加载 ConversationState
3. 提取客户端本轮新输入（通常是最后一条 user message）
4. 忽略客户端回放的 assistant/thinking/tool 历史
5. 使用服务端权威历史 + 本轮输入构造下游请求
6. 执行最终 Sanitize
7. 发送下游请求
8. 处理响应，更新状态
9. 返回响应（携带 SCID）
```

### 6.2 IDE 请求处理（无 SCID / SCID 未命中）

```
1. 接收请求
2. 生成新 SCID
3. 使用客户端传入的 messages
4. 执行 Sanitize：
   - 对每个 thinking block：
     - 能通过缓存严格验证 → 保留
     - 不能验证 → 降级为 text 或删除
   - 如有任何不可验证 thinking → 禁用 thinkingConfig
   - 保持 tool_use/tool_result 链条一致
5. 发送下游请求
6. 处理响应，创建状态
7. 返回响应（携带新 SCID）
```

### 6.3 CLI 请求处理（不启用 IDE 兼容层）

```
1. 接收请求
2. 走现有流程（6层签名恢复 + SQLite 持久化）
3. 不生成/不处理 SCID
4. 返回响应
```

---

## 七、统一 Sanitizer

### 7.1 职责

在发送下游请求前的**最后一跳**，确保：
1. **thinkingConfig 与 payload 强一致**
2. **所有 thinking block 都可验证**
3. **tool_use/tool_result 链条完整**

### 7.2 处理规则

**Thinking Block 处理**：

| 情况 | 处理方式 |
|------|---------|
| 缓存命中且文本完全匹配 | 保留，使用缓存的 signature |
| 缓存命中但文本不匹配 | 降级为 text 或删除 |
| 缓存未命中 | 降级为 text 或删除 |

**降级策略选项**：
- **A) 降级为 text**：`{"type": "text", "text": "<think>...</think>"}`，保留上下文语义
- **B) 直接删除**：更稳定，但损失上下文

**thinkingConfig 联动**：
- 如有任何 thinking 被降级/删除 → 禁用 thinkingConfig
- 如所有 thinking 都可验证 → 保留 thinkingConfig

### 7.3 工具调用处理

**不变量**：
- tool_use 和 tool_result 必须成对（id 对齐）
- 孤儿 tool_result 需要处理（文本化摘要或删除）

**处理策略**：
- 工具回合优先走"弱无状态"：禁用 thinkingConfig + 降级 thinking
- 保留 tool_result 语义（必要时文本化）

---

## 八、内容 Hash 辅助缓存

### 8.1 设计目的

作为 SCID 状态机的**补充层**，解决以下场景：
- SCID 未命中但工具内容相同
- 跨会话的签名复用

### 8.2 Hash 生成规则

```
content_hash = SHA256(tool_name + ":" + sorted_json(tool_input))[:16]
```

### 8.3 数据模型

```sql
CREATE TABLE IF NOT EXISTS content_hash_cache (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    content_hash TEXT UNIQUE NOT NULL,
    tool_name TEXT NOT NULL,
    signature TEXT NOT NULL,
    thinking_preview TEXT DEFAULT '',
    created_at TEXT NOT NULL,
    expires_at TEXT,
    access_count INTEGER DEFAULT 0
);

CREATE INDEX IF NOT EXISTS idx_content_hash ON content_hash_cache(content_hash);
```

### 8.4 使用时机

```
签名恢复优先级（IDE 路径）：
1. SCID 状态机中的权威历史
2. 现有 6 层恢复策略
3. 内容 Hash 缓存（新增）
4. 降级处理
```

---

## 九、响应处理与状态更新

### 9.1 响应处理流程

```
1. 从下游响应提取 assistant blocks
2. 对 thinking/redacted_thinking：
   - 提取 (thinking_text, signature) 配对
   - 写入现有缓存体系（Layer 2/3）
   - 写入 ConversationState（权威历史）
3. 对 tool_use：
   - 维持现有"编码 tool_id + tool_id cache"策略
   - 生成 content_hash 并缓存
   - 更新 ConversationState.tool_map
4. 返回响应时携带 SCID
```

### 9.2 状态更新规则

```
每次成功响应后：
1. 追加本轮 user message 到 history
2. 追加本轮 assistant message 到 history（使用原始未变形的内容）
3. 更新 last_valid_thinking（如有新的 thinking）
4. 更新 tool_map（如有新的 tool_use）
5. 更新 updated_at
6. 持久化到 SQLite
```

---

## 十、配置与开关

### 10.1 Feature Flags

```python
# IDE 兼容层总开关
IDE_COMPAT_ENABLED = os.environ.get("IDE_COMPAT_ENABLED", "true").lower() == "true"

# SCID 状态机开关
SCID_STATE_MACHINE_ENABLED = os.environ.get("SCID_STATE_MACHINE_ENABLED", "true").lower() == "true"

# 状态 TTL（秒）
STATE_TTL_SECONDS = int(os.environ.get("STATE_TTL_SECONDS", "3600"))

# 最大历史轮数
STATE_MAX_TURNS = int(os.environ.get("STATE_MAX_TURNS", "50"))

# 不可验证 thinking 的处理方式
INVALID_THINKING_STRATEGY = os.environ.get("INVALID_THINKING_STRATEGY", "downgrade_to_text")
# 可选值: "downgrade_to_text", "delete"

# 内容 Hash 缓存开关
CONTENT_HASH_CACHE_ENABLED = os.environ.get("CONTENT_HASH_CACHE_ENABLED", "true").lower() == "true"
```

### 10.2 默认值建议

| 配置项 | 默认值 | 说明 |
|--------|--------|------|
| IDE_COMPAT_ENABLED | true | 启用 IDE 兼容层 |
| SCID_STATE_MACHINE_ENABLED | true | 启用 SCID 状态机 |
| STATE_TTL_SECONDS | 3600 | 状态保留 1 小时 |
| STATE_MAX_TURNS | 50 | 最多保留 50 轮对话 |
| INVALID_THINKING_STRATEGY | downgrade_to_text | 降级为 text（保留上下文） |
| CONTENT_HASH_CACHE_ENABLED | true | 启用内容 Hash 缓存 |

---

## 十一、新增模块清单

### 11.1 核心模块

| 模块 | 文件路径 | 职责 |
|------|---------|------|
| **ClientTypeDetector** | `src/ide_compat/client_detector.py` | 检测客户端类型 |
| **ConversationStateManager** | `src/ide_compat/state_manager.py` | SCID 状态管理 |
| **AnthropicSanitizer** | `src/ide_compat/sanitizer.py` | Payload 校验与修复 |
| **ContentHashCache** | `src/ide_compat/content_hash_cache.py` | 内容 Hash 缓存 |
| **IDECompatMiddleware** | `src/ide_compat/middleware.py` | 中间件入口 |

### 11.2 数据库扩展

| 表 | 文件 | 说明 |
|----|------|------|
| conversation_state | `src/cache/signature_database.py` | 扩展现有文件 |
| content_hash_cache | `src/cache/signature_database.py` | 扩展现有文件 |

### 11.3 路由集成

| 路由文件 | 修改点 |
|---------|--------|
| `antigravity_router.py` | 添加 IDE 兼容层中间件调用 |
| `unified_gateway_router.py` | 添加 IDE 兼容层中间件调用 |

---

## 十二、开发任务拆分

### Phase 1: 基础设施（预计 1-2 天）

1. **创建 `src/ide_compat/` 目录结构**
2. **实现 ClientTypeDetector**
   - User-Agent 检测
   - 路径检测
   - 配置化规则
3. **扩展 SignatureDatabase**
   - 添加 conversation_state 表
   - 添加 content_hash_cache 表
   - 实现 CRUD 方法

### Phase 2: 状态机核心（预计 2-3 天）

4. **实现 ConversationStateManager**
   - SCID 生成
   - 状态加载/保存
   - TTL 管理
   - LRU 淘汰
5. **实现 ContentHashCache**
   - Hash 生成
   - 缓存读写
   - 与现有缓存体系集成

### Phase 3: Sanitizer（预计 2 天）

6. **实现 AnthropicSanitizer**
   - Thinking block 验证
   - 降级/删除逻辑
   - thinkingConfig 联动
   - Tool 链条验证
7. **实现 IDECompatMiddleware**
   - 请求拦截
   - 流程编排
   - 响应处理

### Phase 4: 集成与测试（预计 2 天）

8. **路由集成**
   - 修改 antigravity_router.py
   - 修改 unified_gateway_router.py
9. **测试用例**
   - IDE 请求模拟
   - Thinking 变形场景
   - 工具调用场景
   - SCID 续传场景

---

## 十三、验证检查点

### 13.1 功能验证

- [ ] IDE 请求被正确识别
- [ ] CLI 请求走原有流程
- [ ] SCID 正确生成和传递
- [ ] 状态正确存储和加载
- [ ] 不可验证 thinking 被正确降级
- [ ] thinkingConfig 与 payload 一致
- [ ] 工具调用链条完整
- [ ] 内容 Hash 缓存命中

### 13.2 错误消除验证

- [ ] 不再出现 `Invalid signature in thinking block`
- [ ] 不再出现 `thinking disabled but thinking block present`
- [ ] 工具调用后对话不再中断

### 13.3 性能验证

- [ ] 状态加载延迟 < 10ms
- [ ] SQLite 写入不阻塞响应
- [ ] 内存占用可控

---

## 十四、与现有架构的关系

### 14.1 复用关系

```
现有架构                          本方案
─────────────────────────────────────────────────────
SignatureDatabase (SQLite)  ──→  扩展表结构
CacheFacade                 ──→  添加新接口
signature_cache.py          ──→  添加新便捷函数
6层签名恢复策略             ──→  作为 IDE 路径的子策略
Tool/Session Cache          ──→  继续使用
```

### 14.2 不影响的部分

- Claude Code 等 CLI 客户端的处理流程
- 现有的签名缓存逻辑
- 现有的 OpenAI 兼容层
- 现有的 Augment NDJSON 格式转换

---

## 十五、风险与缓解

| 风险 | 影响 | 缓解措施 |
|------|------|---------|
| 状态存储膨胀 | 磁盘占用增加 | TTL + LRU 淘汰 |
| SCID 传递失败 | 回退到无状态模式 | 无状态模式也能工作（降级） |
| 客户端不支持 Header | 无法续传 SCID | 支持 Body 传递作为备选 |
| Sanitizer 误判 | 正常 thinking 被降级 | 严格验证 + 日志监控 |

---

## 十六、总结

本方案通过以下机制解决 IDE 兼容性问题：

1. **客户端类型检测**：区分 IDE 和 CLI，针对性处理
2. **SCID 状态机**：网关成为权威状态机，不信任 IDE 回放
3. **统一 Sanitizer**：最后一跳校验，确保 payload 合法
4. **内容 Hash 缓存**：辅助签名恢复，提高命中率
5. **优雅降级**：不可验证时降级为 text，保证不 400

**核心原则**：
- 可验证 → 保留 extended thinking
- 不可验证 → 降级但不中断

---

**文档版本**: 1.0
**最后更新**: 2026-01-17
**下一步**: 由后续 Agent 按 Phase 1-4 顺序实施开发

祝开发顺利喵～ ฅ'ω'ฅ
