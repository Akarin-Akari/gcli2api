## gcli2api 风控 / 限流缺口与改进计划

> 目的：总结当前自研网关在 Google / Antigravity 上游风控、限流应对上的**缺漏点**，并附上现有代码位置，指导后续由 Claude/浮浮酱继续迭代实现。

对比对象：
- 官方 Python 版：`gcli2api_official`
- Rust 版桌面端：`Antigravity-Manager`

---

## 一、RetryInfo / quotaResetDelay 精确解析缺失

### 现状

- 主要代码位置：`src/antigravity_api.py`
  - 已经有：
    - `parse_and_log_cooldown(error_text, mode="antigravity")`
    - `_resolve_429_cooldown_until(...)`：必要时会主动请求 quota 信息做兜底冷却
    - `_compute_429_retry_delay(...)`：指数退避 + 抖动，最大 30 分钟
  - 但目前**没有一个独立的**「通用 429 RetryInfo / quotaResetDelay 解析函数」，所有逻辑分散：
    - 有处理 `Retry-After` 头
    - 有处理 quota reset / 冷却时间
    - 但没有像 Rust 版那样明确从错误 JSON 中抓 `RetryInfo.retryDelay` / `metadata.quotaResetDelay` 的单点函数。

### 对标实现

- Antigravity-Manager：
  - 路径：`Antigravity-Manager/src-tauri/src/proxy/upstream/retry.rs`
  - 提供：
    - `parse_duration_ms("1.5s" / "13h19m...") -> ms`
    - `parse_retry_delay(error_text) -> Option<u64>`：
      - 优先解析 `RetryInfo.retryDelay`
      - 其次解析 `metadata.quotaResetDelay`

### 建议改进

1. 在 `gcli2api/src` 新增模块（示例命名）：
   - `retry_utils.py`
   - 提供：
     - `parse_duration_ms(s: str) -> Optional[int]`
     - `parse_retry_delay(error_text: str) -> Optional[int]`
   - 逻辑参考 Rust 版 `retry.rs`。
2. 在 `antigravity_api.py` 的 429 处理路径中：
   - 第一优先级调用 `parse_retry_delay(error_text)` 得到精确延迟；
   - 第二优先级使用 HTTP 头 `Retry-After`；
   - 第三优先级才使用 quota 刷新 / 阶梯锁定的兜底逻辑。

---

## 二、统一的“限流状态池”（账号 / 模型级）缺失

### 现状

- 相关代码散布在：
  - `src/antigravity_api.py`
    - 有 `_record_429_failure()` 等辅助函数，用于更新 BaseURL 健康状态和 quota 缓存。
  - `src/fallback_manager.py`
    - 根据 quota 结果决定某个模型池是否“还有额度”。
  - `src/smart_warmup.py`
    - 会根据配额自动禁用 / 启用凭证。
- 目前这些信息**没有集中到一个“账号/模型级限流状态表”里**，也没有类似 “mark_rate_limited(email, model, until, reason)” 的统一入口。

### 对标实现

- Antigravity-Manager：
  - `src-tauri/src/proxy/handlers/openai.rs` / `gemini.rs` / `claude.rs`：
    - 捕获 429/503/529/500 等错误后，会统一调用：
      - `token_manager.mark_rate_limited(_async)(email, status_code, retry_after, error_text, Some(model))`
    - 该状态用于：
      - UI 展示（哪个账号/模型当前在 cooldown）
      - 账号轮换与路由决策（避免选到“刚被限流”的模型）。

### 建议改进

1. 设计一个统一的数据结构，例如：

   ```python
   # 伪代码示例
   class RateLimitState(BaseModel):
       last_status: int
       last_error: str
       cooldown_until: float | None
       last_retry_after: float | None

   # keys:
   #   ("credential_name", "model_name") -> RateLimitState
   rate_limit_registry: Dict[Tuple[str, str], RateLimitState]
   ```

2. 在以下位置统一调用“标记限流”方法：
   - `antigravity_api.py`：所有 Antigravity 429/5xx/403/401 路径
   - （未来）`gcli_chat_api.py`：针对 Google Gemini 上游
3. 后续可在：
   - 账号选择逻辑（credential manager）
   - model routing / fallback 决策
   - Web 控制面板（基于 `web_routes.py`）
   中直接消费这个状态池，清晰可视化“哪些账号/模型在 cooldown 中”。

---

## 三、请求最小间隔 RateLimiter（防抖）缺失

### 现状

- 目前自研版主要通过：
  - 信号量限制并发（`antigravity_api.py` 中的 `_antigravity_concurrency_semaphore`）
  - 429 退避 / 冷却策略
- 缺少类似“**单账号/单模型/全局最小调用间隔**”的 RateLimiter：
  - 即：确保对同一个上游通道的调用至少间隔 N ms，主动削峰。

### 对标实现

- Antigravity-Manager：
  - 路径：`src-tauri/src/proxy/common/rate_limiter.rs`
  - `RateLimiter::wait()`：
    - 维护一个 `last_call` 时间；
    - 如果距离上次调用未超过 `min_interval`（如 500ms），则 sleep 剩余时间。

### 建议改进

1. 在 Python 侧新增一个简易 RateLimiter 类（可放在 `src/rate_limiter.py`）：

   ```python
   class RateLimiter:
       def __init__(self, min_interval_ms: int):
           self._min_interval = min_interval_ms / 1000.0
           self._last_call = 0.0
           self._lock = asyncio.Lock()

       async def wait(self) -> None:
           async with self._lock:
               now = time.monotonic()
               delta = now - self._last_call
               if delta < self._min_interval:
                   await asyncio.sleep(self._min_interval - delta)
               self._last_call = time.monotonic()
   ```

2. 在关键上游调用入口（如 `antigravity_api.py` 的请求发送处）集成：
   - 全局一个 limiter；
   - 或“按账号”/“按模型”实例化 limiter（需要更多状态管理）。

---

## 四、Cloudflared / 隧道级可达性方案缺失（可选增强）

### 现状

- 当前 `gcli2api` 没有自带 Cloudflared 或类似“反向隧道”组件，全部通过常规 HTTP/TLS 直连上游。

### 对标实现

- Antigravity-Manager：
  - 路径：`src-tauri/src/modules/cloudflared.rs`
  - 能够：
    - 自动下载并安装 `cloudflared`
    - 启动到本地服务的隧道
    - 监控进程存活与 URL 状态

### 建议改进（仅在需要时考虑）

- 如果未来希望在“受限网络环境下”提升稳定性，可以：
  1. 在 Python 侧提供配置项，允许通过本地运行的 Cloudflared/Tunnel 来访问上游；
  2. 文档中提示如何在宿主机/容器中部署 Cloudflared；
  3. 网关层面只需支持“通过代理 URL 访问”即可，不一定要自己管理隧道进程。

---

## 五、按状态码细粒度 Retry 策略的枚举化不足

### 现状

- 在自研版中，重试/降级策略分布在多个模块：
  - 统一网关：`unified_gateway_router.py` 中的 `RETRY_CONFIG` 只针对 5xx 做指数退避（并且有 Copilot 熔断）。
  - Antigravity：`antigravity_api.py` 针对 429 有较复杂的重试与 cooldown。
- 未见一个“集中列出**所有 HTTP 状态码 → 重试/轮换/停止策略**”的枚举式结构，逻辑相对分散。

### 对标实现

- Antigravity-Manager：
  - 在 `proxy/handlers/claude.rs` 中定义：

    ```rust
    enum RetryStrategy {
        NoRetry,
        FixedDelay(Duration),
        LinearBackoff { base_ms: u64 },
        ExponentialBackoff { base_ms: u64, max_ms: u64 },
    }
    ```

  - 并在 `determine_retry_strategy(status_code, error_text, retried_without_thinking)` 中：
    - 对 400/429/503/529/500/401/403 分别指定策略。

### 建议改进

1. 在 Python 侧引入类似的“策略枚举”：

   ```python
   @dataclass
   class RetryStrategy:
       kind: Literal["none", "fixed", "linear", "exponential"]
       base_ms: int = 0
       max_ms: int = 0
   ```

2. 在单一位置（例如 `retry_utils.py` 或 `antigravity_retry_policies.py`）写出：
   - `determine_retry_strategy(status_code: int, error_text: str) -> RetryStrategy`
   - 并在所有 handler 调用统一入口。

这样可以让后续维护/调参时只改一个地方，同时也更容易写文档和测试。

---

## 六、后续开发建议（给 Claude / 浮浮酱看的“TODO 队列”）

1. **实现 `retry_utils.py` 中的 `parse_retry_delay()`（优先任务）**
   - 参考 Antigravity-Manager 的 `retry.rs`；
   - 在 `antigravity_api.py` 的 429 流程中优先使用。

2. **设计并实现“限流状态池”模块**
   - 定义数据结构 & 统一的 `mark_rate_limited(...)` 函数；
   - 在 Antigravity/GCLI 的上游调用中接入；
   - 在 Web 控制台增加简单查看接口。

3. **新增 RateLimiter 并在 Antigravity 请求发送处接入**

4. **（可选）抽象 Retry 策略枚举，统一 4xx/5xx 行为**

5. **（视需求）支持通过 Cloudflared 等隧道访问上游**

本文件作为风控/限流方向的“缺口蓝图”，后续每次改动应更新对应章节，以保持设计与实现的一致性。 ***

