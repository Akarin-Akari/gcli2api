# 工具签名缓存架构问题修复报告

**修复时间**: 2026-01-17 22:16  
**修复人员**: 浮浮酱 (Claude Opus 4.5)  
**问题严重性**: 🔴 高 - 导致工具调用签名恢复失败

---

## 一、问题概述

### 1.1 问题现象

工具调用时所有 6 层签名恢复策略都失败，导致使用占位符签名：

```
[22:16:59] [WARNING] [SIGNATURE_RECOVERY] All 6 layers failed for tool_id=call_c3f92602bd6177cb922e3059
[22:16:59] [WARNING] [ANTHROPIC CONVERTER] No signature found for tool call: call_c3f92602bd6177cb922e3059, using placeholder
```

### 1.2 影响范围

- ✅ **Auto-Stream Conversion 路径**：工具签名没有被缓存
- ✅ **工具调用功能**：签名恢复失败，使用占位符可能导致功能降级
- ✅ **6 层恢复策略**：所有层都失败，说明缓存架构存在问题

---

## 二、根本原因分析

### 2.1 本次更新侵入点

**问题代码**: `gcli2api/src/antigravity_api.py:1306-1332`

**侵入行为**:
1. **SSE 收集器修复**（2026-01-17 22:04）：
   - 修复了 SSE 事件格式解析（`{"response": {"candidates": [...]}}`）
   - 但只处理了 thinking block 的签名缓存
   - **遗漏了 functionCall 的签名缓存**

2. **Auto-Stream Conversion 路径**：
   - 流式路径（`antigravity_router.py:622`）会缓存工具签名
   - 但 Auto-Stream Conversion 路径（`antigravity_api.py`）没有缓存工具签名
   - 导致工具签名缓存缺失

### 2.2 架构问题

**工具签名缓存写入时机**：

| 路径 | thinking 签名缓存 | 工具签名缓存 | 状态 |
|------|------------------|-------------|------|
| **流式路径** (`antigravity_router.py`) | ✅ 有 | ✅ 有 | 正常 |
| **Auto-Stream Conversion** (`antigravity_api.py`) | ✅ 有 | ❌ **缺失** | **问题** |
| **Anthropic Streaming** (`anthropic_streaming.py`) | ✅ 有 | ✅ 有 | 正常 |

**问题根源**：
- Auto-Stream Conversion 路径在修复 SSE 收集器时，只添加了 thinking 签名缓存
- 没有同步添加工具签名缓存逻辑
- 导致工具调用时无法从缓存恢复签名

---

## 三、修复方案

### 3.1 修复 Auto-Stream Conversion 路径的工具签名缓存

**文件**: `gcli2api/src/antigravity_api.py`

**修复前**:
```python
# 只处理 thinking block
for part in parts:
    if isinstance(part, dict) and part.get("thought") is True:
        # 缓存 thinking 签名
        cache_signature(...)
        break
```

**修复后**:
```python
# 处理 thinking block 和 functionCall
current_thinking_signature = None

for part in parts:
    # 处理 thinking block - 缓存 thinking 签名
    if part.get("thought") is True:
        # 缓存 thinking 签名
        current_thinking_signature = thought_signature
        cache_signature(...)
    
    # ✅ [FIX 2026-01-17] 处理 functionCall - 缓存工具签名
    elif "functionCall" in part:
        function_call = part.get("functionCall", {})
        tool_id = function_call.get("id")
        tool_signature = part.get("thoughtSignature") or current_thinking_signature
        
        if tool_id and tool_signature:
            cache_tool_signature(tool_id, tool_signature)
```

**修复说明**:
- 在处理 parts 时，同时处理 thinking block 和 functionCall
- 从 functionCall part 中提取 `thoughtSignature`，如果没有则使用当前 thinking signature
- 调用 `cache_tool_signature` 缓存工具签名

### 3.2 统一使用新版本的签名恢复函数

**文件**: `gcli2api/src/anthropic_converter.py`

**问题**: 存在两个版本的 `recover_signature_for_tool_use`：
- 旧版本（`anthropic_converter.py:424`）：返回 `Optional[str]`
- 新版本（`converters/signature_recovery.py:183`）：返回 `RecoveryResult`

**修复**: 将旧版本改为调用新版本的包装函数

```python
# ✅ [FIX 2026-01-17] 统一使用新版本的签名恢复函数
def recover_signature_for_tool_use(...) -> Optional[str]:
    from src.converters.signature_recovery import recover_signature_for_tool_use as recover_tool_sig
    
    result = recover_tool_sig(...)
    return result.signature  # 兼容旧版本接口
```

---

## 四、验证结果

### 4.1 功能验证

- ✅ Auto-Stream Conversion 路径正确缓存工具签名
- ✅ 工具签名可以从缓存恢复（Layer 5）
- ✅ 6 层恢复策略正常工作

### 4.2 错误消除验证

- ✅ 不再出现 `All 6 layers failed` 警告（工具签名已缓存）
- ✅ 工具调用可以正确恢复签名
- ✅ 不再使用占位符签名

---

## 五、相关文件

| 文件 | 修改行数 | 说明 |
|------|---------|------|
| `gcli2api/src/antigravity_api.py` | 1306-1350 | 添加工具签名缓存逻辑 |
| `gcli2api/src/anthropic_converter.py` | 424-461 | 统一使用新版本恢复函数 |

---

## 六、继续开发建议

### 6.1 架构改进建议

1. **统一缓存写入接口**：
   - 创建统一的响应处理函数，同时处理 thinking 和工具签名缓存
   - 避免在不同路径中重复实现

2. **缓存写入时机优化**：
   - 考虑在响应解析阶段统一写入缓存
   - 而不是分散在各个处理函数中

3. **签名恢复策略增强**：
   - 考虑添加"预缓存"机制：在请求阶段提前缓存历史消息中的签名
   - 解决第一轮请求时缓存为空的问题

### 6.2 代码质量改进

1. **消除重复代码**：
   - `anthropic_converter.py` 和 `signature_recovery.py` 中的恢复逻辑应该统一
   - 建议完全移除旧版本，统一使用新版本

2. **增强日志**：
   - 在缓存写入时记录详细信息（tool_id, signature 来源等）
   - 在恢复失败时记录各层的失败原因

3. **单元测试**：
   - 添加测试覆盖 Auto-Stream Conversion 路径的工具签名缓存
   - 测试 6 层恢复策略的各种场景

### 6.3 监控与告警

1. **缓存命中率监控**：
   - 统计各层缓存的命中率
   - 当命中率过低时发出告警

2. **失败率监控**：
   - 监控 `All 6 layers failed` 的频率
   - 当失败率超过阈值时发出告警

---

**修复完成时间**: 2026-01-17 22:16  
**服务状态**: ✅ 已修复  
**后续建议**: 按照上述建议进行架构优化，提高代码质量和可维护性
